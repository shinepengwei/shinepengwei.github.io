---
layout: post
title: C++内存管理（转+笔记）
category: "编程"
tag: "C++"
---
<p><span style="color:#4b4b4b; font-size:8pt"><strong><span style="font-family:Verdana"> [</span><span style="font-family:黑体">导语</span></strong><span style="font-family:Verdana"><strong>]</strong>
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:新宋体">内存管理是C++最令人切齿痛恨的问题，也是C++最有争议的问题，C++高手从中获得了更好的性能，更大的自由，C++菜鸟的收获则是一遍一遍的检查代码和对C++的痛恨，但内存管理在C++中无处不在，内存泄漏几乎在每个C++程序中都会发生，因此要想成为C++高手，内存管理一关是必须要过的，除非放弃C++，转到Java或者.NET，他们的内存管理基本是自动的，当然你也放弃了自由和对内存的支配权，还放弃了C++超绝的性能。本期专题将从内存管理、内存泄漏、内存回收这三个方面来探讨C++内存管理问题。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#666666; font-size:9pt"><strong><span style="font-family:Verdana">1?</span><span style="font-family:宋体">内存管理</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">伟大的</span><span style="font-family:Verdana">Bill Gates?</span><span style="font-family:宋体">曾经失言：</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">640K ought to be enough for everybody?</span><span style="font-family:宋体">—</span><span style="font-family:Verdana">?Bill Gates 1981
</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">程序员们经常编写内存管理程序，往往提心吊胆。如果不想触雷，唯一的解决办法就是发现所有潜伏的地雷并且排除它们，躲是躲不了的。本文的内容比一般教科书的要深入得多，读者需细心阅读，做到真正地通晓内存管理。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:18pt"><strong><span style="font-family:Verdana">1.1 C++</span><span style="font-family:黑体">内存管理详解</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:15pt"><strong><span style="font-family:Verdana">1.1.1?</span><span style="font-family:宋体">内存分配方式</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:12pt"><strong><span style="font-family:Verdana">1.1.1.1?</span><span style="font-family:黑体">分配方式简介</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　在</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">中，内存分成</span><span style="font-family:Verdana">5</span><span style="font-family:宋体">个区，他们分别是堆、栈、自由存储区、全局</span><span style="font-family:Verdana">/</span><span style="font-family:宋体">静态存储区和常量存储区。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　堆，就是那些由</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">就要对应一个</span><span style="font-family:Verdana">delete</span><span style="font-family:宋体">。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　自由存储区，就是那些由</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">等分配的内存块，他和堆是十分相似的，不过它是用</span><span style="font-family:Verdana">free</span><span style="font-family:宋体">来结束自己的生命的。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　全局</span><span style="font-family:Verdana">/</span><span style="font-family:宋体">静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的</span><span style="font-family:Verdana">C</span><span style="font-family:宋体">语言中，全局变量又分为初始化的和未初始化的，在</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">里面没有这个区分了，他们共同占用同一块内存区。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-family:宋体; font-size:8pt">常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。
</span></p><p><span style="color:#4b4b4b; font-family:宋体; font-size:8pt"><span style="background-color:yellow">程序的内存空间</span>
		</span></p><p><span style="color:#4b4b4b; font-family:宋体; font-size:8pt">??? 一个程序将操作系统分配给其运行的内存块分为4个区域，如下图所示。
</span></p><div><table style="border-collapse:collapse; background: white" border="0"><colgroup><col style="width:163px"/><col style="width:142px"/></colgroup><tbody valign="top"><tr><td style="border-top:  outset 0.75pt; border-left:  outset 0.75pt; border-bottom:  outset 0.75pt; border-right:  outset 0.75pt"><p><span style="color:#4b4b4b; font-family:宋体; font-size:8pt">代码区(code area)</span></p></td><td rowspan="4" style="border-top:  outset 0.75pt; border-left:  none; border-bottom:  outset 0.75pt; border-right:  outset 0.75pt"><p><span style="color:#4b4b4b; font-family:宋体; font-size:8pt">程序内存空间</span></p></td></tr><tr><td style="border-top:  none; border-left:  outset 0.75pt; border-bottom:  outset 0.75pt; border-right:  outset 0.75pt"><p><span style="color:#4b4b4b; font-family:宋体; font-size:8pt">全局数据区(data area)</span></p></td></tr><tr><td style="border-top:  none; border-left:  outset 0.75pt; border-bottom:  outset 0.75pt; border-right:  outset 0.75pt"><p><span style="color:#4b4b4b; font-family:宋体; font-size:8pt">堆区(heap area)</span></p></td></tr><tr><td style="border-top:  none; border-left:  outset 0.75pt; border-bottom:  outset 0.75pt; border-right:  outset 0.75pt"><p><span style="color:#4b4b4b; font-family:宋体; font-size:8pt">栈区(stack area)</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-family:宋体; font-size:8pt"><br/>????一个由C/C++编译的程序占用的内存分为以下几个部分：
</span></p><p><span style="color:#4b4b4b; font-family:宋体; font-size:8pt">??? 1、栈区（stack）??由编译器自动分配释放，存放为运行函数而分配的局部变量、函数参数、返回数据、返回地址等。其操作方式类似于数据结构中的栈。
</span></p><p><span style="color:#4b4b4b; font-family:宋体; font-size:8pt">??? 2、堆区（heap）???一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。分配方式类似于链表。
</span></p><p><span style="color:#4b4b4b; font-family:宋体; font-size:8pt">??? 3、全局区（静态区）（static）存放全局变量、静态数据、常量。程序结束后有系统释放
</span></p><p><span style="color:#4b4b4b; font-family:宋体; font-size:8pt">??? 4、文字常量区常量字符串就是放在这里的。?程序结束后由系统释放。
</span></p><p><span style="color:#4b4b4b; font-family:宋体; font-size:8pt">??? 5、程序代码区存放函数体（类成员函数和全局函数）的二进制代码。
</span></p><p>
?</p><p><span style="color:#4b4b4b; font-size:12pt"><strong><span style="font-family:Verdana">1.1.1.2?</span><span style="font-family:黑体">明确区分堆与栈</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　在</span><span style="font-family:Verdana">bbs</span><span style="font-family:宋体">上，堆与栈的区分问题，似乎是一个永恒的话题，由此可见，初学者对此往往是混淆不清的，所以我决定拿他第一个开刀。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　首先，我们举一个例子：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">void f() { int* p=new int[5]; }</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　这条短短的一句话就包含了堆与栈，看到</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">，我们首先就应该想到，我们分配了一块堆内存，那么指针</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">呢？他分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">。在程序会先确定在堆中分配内存的大小，然后调用</span><span style="font-family:Verdana">operator new</span><span style="font-family:宋体">分配内存，然后返回这块内存的首地址，放入栈中，他在</span><span style="font-family:Verdana">VC6</span><span style="font-family:宋体">下的汇编代码如下：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">00401028 push 14h
</span></p><p><span style="font-family:Verdana; font-size:8pt">0040102A call operator new (00401060)
</span></p><p><span style="font-family:Verdana; font-size:8pt">0040102F add esp,4
</span></p><p><span style="font-family:Verdana; font-size:8pt">00401032 mov dword ptr [ebp-8],eax
</span></p><p><span style="font-family:Verdana; font-size:8pt">00401035 mov eax,dword ptr [ebp-8]
</span></p><p><span style="font-family:Verdana; font-size:8pt">00401038 mov dword ptr [ebp-4],eax</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　这里，我们为了简单并没有释放内存，那么该怎么去释放呢？是</span><span style="font-family:Verdana">delete p</span><span style="font-family:宋体">么？澳，错了，应该是</span><span style="font-family:Verdana">delete []p</span><span style="font-family:宋体">，这是为了告诉编译器：我删除的是一个数组，</span><span style="font-family:Verdana">VC6</span><span style="font-family:宋体">就会根据相应的</span><span style="font-family:Verdana">Cookie</span><span style="font-family:宋体">信息去进行释放内存的工作。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:12pt"><strong><span style="font-family:Verdana">1.1.1.3?</span><span style="font-family:黑体">堆和栈究竟有什么区别？</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　好了，我们回到我们的主题：堆和栈究竟有什么区别？</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　主要的区别由以下几点：</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">1</span><span style="font-family:宋体">、管理方式不同；</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">2</span><span style="font-family:宋体">、空间大小不同；</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">3</span><span style="font-family:宋体">、能否产生碎片不同；</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">4</span><span style="font-family:宋体">、生长方向不同；</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">5</span><span style="font-family:宋体">、分配方式不同；</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">6</span><span style="font-family:宋体">、分配效率不同；</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生</span><span style="font-family:Verdana">memory leak</span><span style="font-family:宋体">。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　空间大小：一般来讲在</span><span style="font-family:Verdana">32</span><span style="font-family:宋体">位系统下，堆内存可以达到</span><span style="font-family:Verdana">4G</span><span style="font-family:宋体">的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在</span><span style="font-family:Verdana">VC6</span><span style="font-family:宋体">下面，默认的栈空间大小是</span><span style="font-family:Verdana">1M</span><span style="font-family:宋体">（好像是，记不清楚了）。当然，我们可以修改：</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　打开工程，依次操作菜单如下：</span><span style="font-family:Verdana">Project-&gt;Setting-&gt;Link</span><span style="font-family:宋体">，在</span><span style="font-family:Verdana">Category?</span><span style="font-family:宋体">中选中</span><span style="font-family:Verdana">Output</span><span style="font-family:宋体">，然后在</span><span style="font-family:Verdana">Reserve</span><span style="font-family:宋体">中设定堆栈的最大值和</span><span style="font-family:Verdana">commit</span><span style="font-family:宋体">。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　注意：</span><span style="font-family:Verdana">reserve</span><span style="font-family:宋体">最小值为</span><span style="font-family:Verdana">4Byte</span><span style="font-family:宋体">；</span><span style="font-family:Verdana">commit</span><span style="font-family:宋体">是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　碎片问题：对于堆来讲，频繁的</span><span style="font-family:Verdana">new/delete</span><span style="font-family:宋体">势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　分配方式：堆都是动态分配的，没有静态分配的堆。栈有</span><span style="font-family:Verdana">2</span><span style="font-family:宋体">种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由</span><span style="font-family:Verdana">alloca</span><span style="font-family:宋体">函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是</span><span style="font-family:Verdana">C/C++</span><span style="font-family:宋体">函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构</span><span style="font-family:Verdana">/</span><span style="font-family:宋体">操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　从这里我们可以看到，堆和栈相比，由于大量</span><span style="font-family:Verdana">new/delete</span><span style="font-family:宋体">的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，</span><span style="font-family:Verdana">EBP</span><span style="font-family:宋体">和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果</span><span style="font-family:Verdana">,</span><span style="font-family:宋体">就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候</span><span style="font-family:Verdana">debug</span><span style="font-family:宋体">可是相当困难的：）</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:15pt"><strong><span style="font-family:Verdana">1.1.2?</span><span style="font-family:宋体">控制</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">的内存分配</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　在嵌入式系统中使用</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">的一个常见问题是内存分配，即对</span><span style="font-family:Verdana">new?</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">?delete?</span><span style="font-family:宋体">操作符的失控。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　具有讽刺意味的是，问题的根源却是</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">对内存的管理非常的容易而且安全。具体地说，当一个对象被消除时，它的析构函数能够安全的释放所分配的内存。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　这当然是个好事情，但是这种使用的简单性使得程序员们过度使用</span><span style="font-family:Verdana">new?</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">?delete</span><span style="font-family:宋体">，而不注意在嵌入式</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">环境中的因果关系。并且，在嵌入式系统中，由于内存的限制，频繁的动态分配不定大小的内存会引起很大的问题以及堆破碎的风险。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　作为忠告，保守的使用内存分配是嵌入式环境中的第一原则。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　但当你必须要使用</span><span style="font-family:Verdana">new?</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">delete</span><span style="font-family:宋体">时，你不得不控制</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">中的内存分配。你需要用一个全局的</span><span style="font-family:Verdana">new?</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">delete</span><span style="font-family:宋体">来代替系统的内存分配符，并且一个类一个类的重载</span><span style="font-family:Verdana">new?</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">delete</span><span style="font-family:宋体">。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　一个防止堆破碎的通用方法是从不同固定大小的内存持中分配不同类型的对象。对每个类重载</span><span style="font-family:Verdana">new?</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">delete</span><span style="font-family:宋体">就提供了这样的控制。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:12pt"><strong><span style="font-family:Verdana">1.1.2.1?</span><span style="font-family:黑体">重载全局的</span><span style="font-family:Verdana">new</span><span style="font-family:黑体">和</span><span style="font-family:Verdana">delete</span><span style="font-family:黑体">操作符</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　可以很容易地重载</span><span style="font-family:Verdana">new?</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">?delete?</span><span style="font-family:宋体">操作符，如下所示</span><span style="font-family:Verdana">:
</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">void * operator new(size_t size)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">void *p = malloc(size);
</span></p><p><span style="font-family:Verdana; font-size:8pt">return (p);
</span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">void operator delete(void *p);
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">free(p);
</span></p><p><span style="font-family:Verdana; font-size:8pt">}?</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　这段代码可以代替默认的操作符来满足内存分配的请求。出于解释</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">的目的，我们也可以直接调用</span><span style="font-family:Verdana">malloc()?</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">free()</span><span style="font-family:宋体">。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　也可以对单个类的</span><span style="font-family:Verdana">new?</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">?delete?</span><span style="font-family:宋体">操作符重载。这是你能灵活的控制对象的内存分配。</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">class TestClass {
</span></p><p><span style="font-family:Verdana; font-size:8pt">public:
</span></p><p><span style="font-family:Verdana; font-size:8pt">void * operator new(size_t size);
</span></p><p><span style="font-family:Verdana; font-size:8pt">void operator delete(void *p);
</span></p><p><span style="font-family:Verdana; font-size:8pt">// .. other members here ...
</span></p><p><span style="font-family:Verdana; font-size:8pt">};
</span></p><p><span style="font-family:Verdana; font-size:8pt">void *TestClass::operator new(size_t size)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">void *p = malloc(size); // Replace this with alternative allocator
</span></p><p><span style="font-family:Verdana; font-size:8pt">return (p);
</span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">void TestClass::operator delete(void *p)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">free(p); // Replace this with alternative de-allocator
</span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　所有</span><span style="font-family:Verdana">TestClass?</span><span style="font-family:宋体">对象的内存分配都采用这段代码。更进一步，任何从</span><span style="font-family:Verdana">TestClass?</span><span style="font-family:宋体">继承的类也都采用这一方式，除非它自己也重载了</span><span style="font-family:Verdana">new?</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">?delete?</span><span style="font-family:宋体">操作符。通过重载</span><span style="font-family:Verdana">new?</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">?delete?</span><span style="font-family:宋体">操作符的方法，你可以自由地采用不同的分配策略，从不同的内存池中分配不同的类对象。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:12pt"><strong><span style="font-family:Verdana">1.1.2.2?</span><span style="font-family:黑体">为单个的类重载</span><span style="font-family:Verdana">?new[ ]</span><span style="font-family:黑体">和</span><span style="font-family:Verdana">delete[ ]
</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　必须小心对象数组的分配。你可能希望调用到被你重载过的</span><span style="font-family:Verdana">new?</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">?delete?</span><span style="font-family:宋体">操作符，但并不如此。内存的请求被定向到全局的</span><span style="font-family:Verdana">new[ ]</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">delete[ ]?</span><span style="font-family:宋体">操作符，而这些内存来自于系统堆。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">将对象数组的内存分配作为一个单独的操作，而不同于单个对象的内存分配。为了改变这种方式，你同样需要重载</span><span style="font-family:Verdana">new[ ]?</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">?delete[ ]</span><span style="font-family:宋体">操作符。</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">class TestClass {
</span></p><p><span style="font-family:Verdana; font-size:8pt">public:
</span></p><p><span style="font-family:Verdana; font-size:8pt">void * operator new[ ](size_t size);
</span></p><p><span style="font-family:Verdana; font-size:8pt">void operator delete[ ](void *p);
</span></p><p><span style="font-family:Verdana; font-size:8pt">// .. other members here ..
</span></p><p><span style="font-family:Verdana; font-size:8pt">};
</span></p><p><span style="font-family:Verdana; font-size:8pt">void *TestClass::operator new[ ](size_t size)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">void *p = malloc(size);
</span></p><p><span style="font-family:Verdana; font-size:8pt">return (p);
</span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">void TestClass::operator delete[ ](void *p)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">free(p);
</span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">int main(void)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">TestClass *p = new TestClass[10];
</span></p><p><span style="font-family:Verdana; font-size:8pt">// ... etc ...
</span></p><p><span style="font-family:Verdana; font-size:8pt">delete[ ] p;
</span></p><p><span style="font-family:Verdana; font-size:8pt">}?</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">但是注意：对于多数</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">的实现，</span><span style="font-family:Verdana">new[]</span><span style="font-family:宋体">操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。在你的内存分配机制重要考虑的这一点。你应该尽量避免分配对象数组，从而使你的内存分配策略简单。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:15pt"><strong><span style="font-family:Verdana">1.1.3?</span><span style="font-family:宋体">常见的内存错误及其对策</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。有时用户怒气冲冲地把你找来，程序却没有发生任何问题，你一走，错误又发作了。</span><span style="font-family:Verdana">?</span><span style="font-family:宋体">常见的内存错误及其对策如下：</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">*?</span><span style="font-family:宋体">内存分配未成功，却使用了它。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为</span><span style="font-family:Verdana">NULL</span><span style="font-family:宋体">。如果指针</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">是函数的参数，那么在函数的入口处用</span><span style="font-family:Verdana">assert(p!=NULL)</span><span style="font-family:宋体">进行</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　检查。如果是用</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">或</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">来申请内存，应该用</span><span style="font-family:Verdana">if(p==NULL)?</span><span style="font-family:宋体">或</span><span style="font-family:Verdana">if(p!=NULL)</span><span style="font-family:宋体">进行防错处理。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">*?</span><span style="font-family:宋体">内存分配虽然成功，但是尚未初始化就引用它。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。</span><span style="font-family:Verdana">?</span><span style="font-family:宋体">内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">*?</span><span style="font-family:宋体">内存分配成功并且已经初始化，但操作越过了内存的边界。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　例如在使用数组时经常发生下标"多</span><span style="font-family:Verdana">1</span><span style="font-family:宋体">"或者"少</span><span style="font-family:Verdana">1</span><span style="font-family:宋体">"的操作。特别是在</span><span style="font-family:Verdana">for</span><span style="font-family:宋体">循环语句中，循环次数很容易搞错，导致数组操作越界。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">*?</span><span style="font-family:宋体">忘记了释放内存，造成内存泄露。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　动态内存的申请与释放必须配对，程序中</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">与</span><span style="font-family:Verdana">free</span><span style="font-family:宋体">的使用次数一定要相同，否则肯定有错误（</span><span style="font-family:Verdana">new/delete</span><span style="font-family:宋体">同理）。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">*?</span><span style="font-family:宋体">释放了内存却继续使用它。</span><span style="font-family:Verdana">
			</span></span></p><p>　
?</p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　有三种情况：</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　（</span><span style="font-family:Verdana">1</span><span style="font-family:宋体">）程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　（</span><span style="font-family:Verdana">2</span><span style="font-family:宋体">）函数的</span><span style="font-family:Verdana">return</span><span style="font-family:宋体">语句写错了，注意不要返回指向"栈内存"的"指针"或者"引用"，因为该内存在函数体结束时被自动销毁。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　（</span><span style="font-family:Verdana">3</span><span style="font-family:宋体">）使用</span><span style="font-family:Verdana">free</span><span style="font-family:宋体">或</span><span style="font-family:Verdana">delete</span><span style="font-family:宋体">释放了内存后，没有将指针设置为</span><span style="font-family:Verdana">NULL</span><span style="font-family:宋体">。导致产生"野指针"。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　【规则</span><span style="font-family:Verdana">1</span><span style="font-family:宋体">】用</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">或</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">申请内存之后，应该立即检查指针值是否为</span><span style="font-family:Verdana">NULL</span><span style="font-family:宋体">。防止使用指针值为</span><span style="font-family:Verdana">NULL</span><span style="font-family:宋体">的内存。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　【规则</span><span style="font-family:Verdana">2</span><span style="font-family:宋体">】不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　【规则</span><span style="font-family:Verdana">3</span><span style="font-family:宋体">】避免数组或指针的下标越界，特别要当心发生"多</span><span style="font-family:Verdana">1</span><span style="font-family:宋体">"或者"少</span><span style="font-family:Verdana">1</span><span style="font-family:宋体">"操作。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　【规则</span><span style="font-family:Verdana">4</span><span style="font-family:宋体">】动态内存的申请与释放必须配对，防止内存泄漏。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　【规则</span><span style="font-family:Verdana">5</span><span style="font-family:宋体">】用</span><span style="font-family:Verdana">free</span><span style="font-family:宋体">或</span><span style="font-family:Verdana">delete</span><span style="font-family:宋体">释放了内存之后，立即将指针设置为</span><span style="font-family:Verdana">NULL</span><span style="font-family:宋体">，防止产生"野指针"。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:15pt"><strong><span style="font-family:Verdana">1.1.4?</span><span style="font-family:宋体">指针与数组的对比</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">C++/C</span><span style="font-family:宋体">程序中，指针和数组在不少地方可以相互替换着用，让人产生一种错觉，以为两者是等价的。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向）一块内存，其地址与容量在生命期内保持不变，只有数组的内容可以改变。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　指针可以随时指向任意类型的内存块，它的特征是"可变"，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　下面以字符串为例比较指针与数组的特性。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:12pt"><strong><span style="font-family:Verdana">1.1.4.1?</span><span style="font-family:黑体">修改内容</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">下面示例中，字符数组</span><span style="font-family:Verdana">a</span><span style="font-family:宋体">的容量是</span><span style="font-family:Verdana">6</span><span style="font-family:宋体">个字符，其内容为</span><span style="font-family:Verdana">hello</span><span style="font-family:宋体">。</span><span style="font-family:Verdana">a</span><span style="font-family:宋体">的内容可以改变，如</span><span style="font-family:Verdana">a[0]=</span><span style="font-family:宋体">'</span><span style="font-family:Verdana">X</span><span style="font-family:宋体">'。指针</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">指向常量字符串"</span><span style="font-family:Verdana">world</span><span style="font-family:宋体">"（位于静态存储区，内容为</span><span style="font-family:Verdana">world</span><span style="font-family:宋体">），常量字符串的内容是不可以被修改的。从语法上看，编译器并不觉得语句</span><span style="font-family:Verdana">p[0]=?</span><span style="font-family:宋体">'</span><span style="font-family:Verdana">X</span><span style="font-family:宋体">'有什么不妥，但是该语句企图修改常量字符串的内容而导致运行错误。</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">char a[] = "hello";
</span></p><p><span style="font-family:Verdana; font-size:8pt">a[0] = 'X';
</span></p><p><span style="font-family:Verdana; font-size:8pt">cout &lt;&lt; a &lt;&lt; endl;
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">char *p =?</span><span style="font-family:宋体">"</span><span style="font-family:Verdana">world</span><span style="font-family:宋体">"</span><span style="font-family:Verdana">; //?</span><span style="font-family:宋体">注意</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">指向常量字符串</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">p[0] =?</span><span style="font-family:宋体">'</span><span style="font-family:Verdana">X</span><span style="font-family:宋体">'</span><span style="font-family:Verdana">; //?</span><span style="font-family:宋体">编译器不能发现该错误</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">cout &lt;&lt; p &lt;&lt; endl;</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:12pt"><strong><span style="font-family:Verdana">1.1.4.2?</span><span style="font-family:黑体">内容复制与比较</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　不能对数组名进行直接复制与比较。若想把数组</span><span style="font-family:Verdana">a</span><span style="font-family:宋体">的内容复制给数组</span><span style="font-family:Verdana">b</span><span style="font-family:宋体">，不能用语句</span><span style="font-family:Verdana">?b = a?</span><span style="font-family:宋体">，否则将产生编译错误。应该用标准库函数</span><span style="font-family:Verdana">strcpy</span><span style="font-family:宋体">进行复制。同理，比较</span><span style="font-family:Verdana">b</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">a</span><span style="font-family:宋体">的内容是否相同，不能用</span><span style="font-family:Verdana">if(b==a)?</span><span style="font-family:宋体">来判断，应该用标准库函数</span><span style="font-family:Verdana">strcmp</span><span style="font-family:宋体">进行比较。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">语句</span><span style="font-family:Verdana">p = a?</span><span style="font-family:宋体">并不能把</span><span style="font-family:Verdana">a</span><span style="font-family:宋体">的内容复制指针</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">，而是把</span><span style="font-family:Verdana">a</span><span style="font-family:宋体">的地址赋给了</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">。要想复制</span><span style="font-family:Verdana">a</span><span style="font-family:宋体">的内容，可以先用库函数</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">为</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">申请一块容量为</span><span style="font-family:Verdana">strlen(a)+1</span><span style="font-family:宋体">个字符的内存，再用</span><span style="font-family:Verdana">strcpy</span><span style="font-family:宋体">进行字符串复制。同理，语句</span><span style="font-family:Verdana">if(p==a)?</span><span style="font-family:宋体">比较的不是内容而是地址，应该用库函数</span><span style="font-family:Verdana">strcmp</span><span style="font-family:宋体">来比较。</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-size:8pt"><span style="font-family:Verdana">//?</span><span style="font-family:宋体">数组…</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">char a[] = "hello";
</span></p><p><span style="font-family:Verdana; font-size:8pt">char b[10];
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">strcpy(b, a); //?</span><span style="font-family:宋体">不能用</span><span style="font-family:Verdana">?b = a;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">if(strcmp(b, a) == 0) //?</span><span style="font-family:宋体">不能用</span><span style="font-family:Verdana">?if (b == a)
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">…</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">//?</span><span style="font-family:宋体">指针…</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">int len = strlen(a);
</span></p><p><span style="font-family:Verdana; font-size:8pt">char *p = (char *)malloc(sizeof(char)*(len+1));
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">strcpy(p,a); //?</span><span style="font-family:宋体">不要用</span><span style="font-family:Verdana">?p = a;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">if(strcmp(p, a) == 0) //?</span><span style="font-family:宋体">不要用</span><span style="font-family:Verdana">?if (p == a)
</span></span></p><p><span style="font-family:宋体; font-size:8pt">…</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:12pt"><strong><span style="font-family:Verdana">1.1.4.3?</span><span style="font-family:黑体">计算内存容量</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">用运算符</span><span style="font-family:Verdana">sizeof</span><span style="font-family:宋体">可以计算出数组的容量（字节数）。如下示例中，</span><span style="font-family:Verdana">sizeof(a)</span><span style="font-family:宋体">的值是</span><span style="font-family:Verdana">12</span><span style="font-family:宋体">（注意别忘了''）。指针</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">指向</span><span style="font-family:Verdana">a</span><span style="font-family:宋体">，但是</span><span style="font-family:Verdana">sizeof(p)</span><span style="font-family:宋体">的值却是</span><span style="font-family:Verdana">4</span><span style="font-family:宋体">。这是因为</span><span style="font-family:Verdana">sizeof(p)</span><span style="font-family:宋体">得到的是一个指针变量的字节数，相当于</span><span style="font-family:Verdana">sizeof(char*)</span><span style="font-family:宋体">，而不是</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">所指的内存容量。</span><span style="font-family:Verdana">C++/C</span><span style="font-family:宋体">语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">char a[] = "hello world";
</span></p><p><span style="font-family:Verdana; font-size:8pt">char *p = a;
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12</span><span style="font-family:宋体">字节</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4</span><span style="font-family:宋体">字节</span></span></p></td></tr></tbody></table></div><p>　　
?</p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。如下示例中，不论数组</span><span style="font-family:Verdana">a</span><span style="font-family:宋体">的容量是多少，</span><span style="font-family:Verdana">sizeof(a)</span><span style="font-family:宋体">始终等于</span><span style="font-family:Verdana">sizeof(char *)</span><span style="font-family:宋体">。</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">void Func(char a[100])
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4</span><span style="font-family:宋体">字节而不是</span><span style="font-family:Verdana">100</span><span style="font-family:宋体">字节</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:15pt"><strong><span style="font-family:Verdana">1.1.5?</span><span style="font-family:宋体">指针参数是如何传递内存的？</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">如果函数的参数是一个指针，不要指望用该指针去申请动态内存。如下示例中，</span><span style="font-family:Verdana">Test</span><span style="font-family:宋体">函数的语句</span><span style="font-family:Verdana">GetMemory(str, 200)</span><span style="font-family:宋体">并没有使</span><span style="font-family:Verdana">str</span><span style="font-family:宋体">获得期望的内存，</span><span style="font-family:Verdana">str</span><span style="font-family:宋体">依旧是</span><span style="font-family:Verdana">NULL</span><span style="font-family:宋体">，为什么？</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">void GetMemory(char *p, int num)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">p = (char *)malloc(sizeof(char) * num);
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">void Test(void)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">char *str = NULL;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">GetMemory(str, 100); // str?</span><span style="font-family:宋体">仍然为</span><span style="font-family:Verdana">?NULL
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">strcpy(str, "hello"); //?</span><span style="font-family:宋体">运行错误</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">毛病出在函数</span><span style="font-family:Verdana">GetMemory</span><span style="font-family:宋体">中。编译器总是要为函数的每个参数制作临时副本，指针参数</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">的副本是</span><span style="font-family:Verdana">?_p</span><span style="font-family:宋体">，编译器使</span><span style="font-family:Verdana">?_p = p</span><span style="font-family:宋体">。如果函数体内的程序修改了</span><span style="font-family:Verdana">_p</span><span style="font-family:宋体">的内容，就导致参数</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">的内容作相应的修改。这就是指针可以用作输出参数的原因。在本例中，</span><span style="font-family:Verdana">_p</span><span style="font-family:宋体">申请了新的内存，只是把</span><span style="font-family:Verdana">_p</span><span style="font-family:宋体">所指的内存地址改变了，但是</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">丝毫未变。所以函数</span><span style="font-family:Verdana">GetMemory</span><span style="font-family:宋体">并不能输出任何东西。事实上，每执行一次</span><span style="font-family:Verdana">GetMemory</span><span style="font-family:宋体">就会泄露一块内存，因为没有用</span><span style="font-family:Verdana">free</span><span style="font-family:宋体">释放内存。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">如果非得要用指针参数去申请内存，那么应该改用"指向指针的指针"，见示例：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">void GetMemory2(char **p, int num)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">*p = (char *)malloc(sizeof(char) * num);
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">void Test2(void)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">char *str = NULL;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">GetMemory2(&amp;str, 100); //?</span><span style="font-family:宋体">注意参数是</span><span style="font-family:Verdana">?&amp;str</span><span style="font-family:宋体">，而不是</span><span style="font-family:Verdana">str
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">strcpy(str, "hello");
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">cout&lt;&lt; str &lt;&lt; endl;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">free(str);
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">由于"指向指针的指针"这个概念不容易理解，我们可以用函数返回值来传递动态内存。这种方法更加简单，见示例：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">char *GetMemory3(int num)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">char *p = (char *)malloc(sizeof(char) * num);
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">return p;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">void Test3(void)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">char *str = NULL;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">str = GetMemory3(100);
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">strcpy(str, "hello");
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">cout&lt;&lt; str &lt;&lt; endl;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">free(str);
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">用函数返回值来传递动态内存这种方法虽然好用，但是常常有人把</span><span style="font-family:Verdana">return</span><span style="font-family:宋体">语句用错了。这里强调不要用</span><span style="font-family:Verdana">return</span><span style="font-family:宋体">语句返回指向"栈内存"的指针，因为该内存在函数结束时自动消亡，见示例：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">char *GetString(void)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">char p[] = "hello world";
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">return p; //?</span><span style="font-family:宋体">编译器将提出警告</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">void Test4(void)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">char *str = NULL;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">str = GetString(); // str?</span><span style="font-family:宋体">的内容是垃圾</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">cout&lt;&lt; str &lt;&lt; endl;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">用调试器逐步跟踪</span><span style="font-family:Verdana">Test4</span><span style="font-family:宋体">，发现执行</span><span style="font-family:Verdana">str = GetString</span><span style="font-family:宋体">语句后</span><span style="font-family:Verdana">str</span><span style="font-family:宋体">不再是</span><span style="font-family:Verdana">NULL</span><span style="font-family:宋体">指针，但是</span><span style="font-family:Verdana">str</span><span style="font-family:宋体">的内容不是"</span><span style="font-family:Verdana">hello world</span><span style="font-family:宋体">"而是垃圾。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">如果把上述示例改写成如下示例，会怎么样？</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">char *GetString2(void)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">char *p = "hello world";
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">return p;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">void Test5(void)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">char *str = NULL;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">str = GetString2();
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">cout&lt;&lt; str &lt;&lt; endl;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">函数</span><span style="font-family:Verdana">Test5</span><span style="font-family:宋体">运行虽然不会出错，但是函数</span><span style="font-family:Verdana">GetString2</span><span style="font-family:宋体">的设计概念却是错误的。因为</span><span style="font-family:Verdana">GetString2</span><span style="font-family:宋体">内的"</span><span style="font-family:Verdana">hello world</span><span style="font-family:宋体">"是常量字符串，位于静态存储区，它在程序生命期内恒定不变。无论什么时候调用</span><span style="font-family:Verdana">GetString2</span><span style="font-family:宋体">，它返回的始终是同一个"只读"的内存块。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:15pt"><strong><span style="font-family:Verdana">1.1.6?</span><span style="font-family:宋体">杜绝"野指针"</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　"野指针"不是</span><span style="font-family:Verdana">NULL</span><span style="font-family:宋体">指针，是指向"垃圾"内存的指针。人们一般不会错用</span><span style="font-family:Verdana">NULL</span><span style="font-family:宋体">指针，因为用</span><span style="font-family:Verdana">if</span><span style="font-family:宋体">语句很容易判断。但是"野指针"是很危险的，</span><span style="font-family:Verdana">if</span><span style="font-family:宋体">语句对它不起作用。</span><span style="font-family:Verdana">?</span><span style="font-family:宋体">"野指针"的成因主要有两种：</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">（</span><span style="font-family:Verdana">1</span><span style="font-family:宋体">）指针变量没有被初始化。任何指针变量刚被创建时不会自动成为</span><span style="font-family:Verdana">NULL</span><span style="font-family:宋体">指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为</span><span style="font-family:Verdana">NULL</span><span style="font-family:宋体">，要么让它指向合法的内存。例如</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">char *p = NULL;
</span></p><p><span style="font-family:Verdana; font-size:8pt">char *str = (char *) malloc(100);</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">（</span><span style="font-family:Verdana">2</span><span style="font-family:宋体">）指针</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">被</span><span style="font-family:Verdana">free</span><span style="font-family:宋体">或者</span><span style="font-family:Verdana">delete</span><span style="font-family:宋体">之后，没有置为</span><span style="font-family:Verdana">NULL</span><span style="font-family:宋体">，让人误以为</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">是个合法的指针。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">（</span><span style="font-family:Verdana">3</span><span style="font-family:宋体">）指针操作超越了变量的作用域范围。这种情况让人防不胜防，示例程序如下：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">class A
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">public:
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">void Func(void){ cout &lt;&lt;?</span><span style="font-family:宋体">"</span><span style="font-family:Verdana">Func of class A</span><span style="font-family:宋体">"</span><span style="font-family:Verdana">?&lt;&lt; endl; }
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">};
</span></p><p><span style="font-family:Verdana; font-size:8pt">void Test(void)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">A *p;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">{
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">A a;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">p = &amp;a; //?</span><span style="font-family:宋体">注意</span><span style="font-family:Verdana">?a?</span><span style="font-family:宋体">的生命期</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">}
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">p-&gt;Func(); // p</span><span style="font-family:宋体">是"野指针"</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">函数</span><span style="font-family:Verdana">Test</span><span style="font-family:宋体">在执行语句</span><span style="font-family:Verdana">p-&gt;Func()</span><span style="font-family:宋体">时，对象</span><span style="font-family:Verdana">a</span><span style="font-family:宋体">已经消失，而</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">是指向</span><span style="font-family:Verdana">a</span><span style="font-family:宋体">的，所以</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">就成了"野指针"。但奇怪的是我运行这个程序时居然没有出错，这可能与编译器有关。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:15pt"><strong><span style="font-family:Verdana">1.1.7?</span><span style="font-family:宋体">有了</span><span style="font-family:Verdana">malloc/free</span><span style="font-family:宋体">为什么还要</span><span style="font-family:Verdana">new/delete</span><span style="font-family:宋体">？</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-family:宋体; font-size:8pt"><span style="background-color:yellow">区别：malloc只能用于内置数据类型，如int等。而如果用malloc为一个对象分配内存的话，它并不去调用构造函数，而函数中的初始化工作就需要其他函数完成。而是用new/delete就可以自动调用构造函数和析构函数。</span>
		</span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">与</span><span style="font-family:Verdana">free</span><span style="font-family:宋体">是</span><span style="font-family:Verdana">C++/C</span><span style="font-family:宋体">语言的标准库函数，</span><span style="font-family:Verdana">new/delete</span><span style="font-family:宋体">是</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">的运算符。它们都可用于申请动态内存和释放内存。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　对于非内部数据类型的对象而言，光用</span><span style="font-family:Verdana">maloc/free</span><span style="font-family:宋体">无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于</span><span style="font-family:Verdana">malloc/free</span><span style="font-family:宋体">是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于</span><span style="font-family:Verdana">malloc/free</span><span style="font-family:宋体">。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">因此</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">语言需要一个能完成动态内存分配和初始化工作的运算符</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">，以及一个能完成清理与释放内存工作的运算符</span><span style="font-family:Verdana">delete</span><span style="font-family:宋体">。注意</span><span style="font-family:Verdana">new/delete</span><span style="font-family:宋体">不是库函数。我们先看一看</span><span style="font-family:Verdana">malloc/free</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">new/delete</span><span style="font-family:宋体">如何实现对象的动态内存管理，见示例：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">class Obj
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">public :
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">Obj(void){ cout &lt;&lt;?</span><span style="font-family:宋体">"</span><span style="font-family:Verdana">Initialization</span><span style="font-family:宋体">"</span><span style="font-family:Verdana">?&lt;&lt; endl; }
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">~Obj(void){ cout &lt;&lt;?</span><span style="font-family:宋体">"</span><span style="font-family:Verdana">Destroy</span><span style="font-family:宋体">"</span><span style="font-family:Verdana">?&lt;&lt; endl; }
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">void Initialize(void){ cout &lt;&lt;?</span><span style="font-family:宋体">"</span><span style="font-family:Verdana">Initialization</span><span style="font-family:宋体">"</span><span style="font-family:Verdana">?&lt;&lt; endl; }
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">void Destroy(void){ cout &lt;&lt;?</span><span style="font-family:宋体">"</span><span style="font-family:Verdana">Destroy</span><span style="font-family:宋体">"</span><span style="font-family:Verdana">?&lt;&lt; endl; }
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">};
</span></p><p><span style="font-family:Verdana; font-size:8pt">void UseMallocFree(void)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">Obj *a = (obj *)malloc(sizeof(obj)); //?</span><span style="font-family:宋体">申请动态内存</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">a-&gt;Initialize(); //?</span><span style="font-family:宋体">初始化</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">//</span><span style="font-family:宋体">…</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">a-&gt;Destroy(); //?</span><span style="font-family:宋体">清除工作</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">free(a); //?</span><span style="font-family:宋体">释放内存</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">void UseNewDelete(void)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">Obj *a = new Obj; //?</span><span style="font-family:宋体">申请动态内存并且初始化</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">//</span><span style="font-family:宋体">…</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">delete a; //?</span><span style="font-family:宋体">清除并且释放内存</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　类</span><span style="font-family:Verdana">Obj</span><span style="font-family:宋体">的函数</span><span style="font-family:Verdana">Initialize</span><span style="font-family:宋体">模拟了构造函数的功能，函数</span><span style="font-family:Verdana">Destroy</span><span style="font-family:宋体">模拟了析构函数的功能。函数</span><span style="font-family:Verdana">UseMallocFree</span><span style="font-family:宋体">中，由于</span><span style="font-family:Verdana">malloc/free</span><span style="font-family:宋体">不能执行构造函数与析构函数，必须调用成员函数</span><span style="font-family:Verdana">Initialize</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">Destroy</span><span style="font-family:宋体">来完成初始化与清除工作。函数</span><span style="font-family:Verdana">UseNewDelete</span><span style="font-family:宋体">则简单得多。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　所以我们不要企图用</span><span style="font-family:Verdana">malloc/free</span><span style="font-family:宋体">来完成动态对象的内存管理，应该用</span><span style="font-family:Verdana">new/delete</span><span style="font-family:宋体">。由于内部数据类型的"对象"没有构造与析构的过程，对它们而言</span><span style="font-family:Verdana">malloc/free</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">new/delete</span><span style="font-family:宋体">是等价的。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　既然</span><span style="font-family:Verdana">new/delete</span><span style="font-family:宋体">的功能完全覆盖了</span><span style="font-family:Verdana">malloc/free</span><span style="font-family:宋体">，为什么</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">不把</span><span style="font-family:Verdana">malloc/free</span><span style="font-family:宋体">淘汰出局呢？这是因为</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">程序经常要调用</span><span style="font-family:Verdana">C</span><span style="font-family:宋体">函数，而</span><span style="font-family:Verdana">C</span><span style="font-family:宋体">程序只能用</span><span style="font-family:Verdana">malloc/free</span><span style="font-family:宋体">管理动态内存。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">如果用</span><span style="font-family:Verdana">free</span><span style="font-family:宋体">释放"</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">创建的动态对象"，那么该对象因无法执行析构函数而可能导致程序出错。如果用</span><span style="font-family:Verdana">delete</span><span style="font-family:宋体">释放"</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">申请的动态内存"，结果也会导致程序出错，但是该程序的可读性很差。所以</span><span style="font-family:Verdana">new/delete</span><span style="font-family:宋体">必须配对使用，</span><span style="font-family:Verdana">malloc/free</span><span style="font-family:宋体">也一样。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:15pt"><strong><span style="font-family:Verdana">1.1.8?</span><span style="font-family:宋体">内存耗尽怎么办？</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　如果在申请动态内存时找不到足够大的内存块，</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">将返回</span><span style="font-family:Verdana">NULL</span><span style="font-family:宋体">指针，宣告内存申请失败。通常有三种方式处理"内存耗尽"问题。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　（</span><span style="font-family:Verdana">1</span><span style="font-family:宋体">）判断指针是否为</span><span style="font-family:Verdana">NULL</span><span style="font-family:宋体">，如果是则马上用</span><span style="font-family:Verdana">return</span><span style="font-family:宋体">语句终止本函数。例如：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">void Func(void)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">A *a = new A;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">if(a == NULL)
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">{
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">return;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">}
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　…</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　（</span><span style="font-family:Verdana">2</span><span style="font-family:宋体">）判断指针是否为</span><span style="font-family:Verdana">NULL</span><span style="font-family:宋体">，如果是则马上用</span><span style="font-family:Verdana">exit(1)</span><span style="font-family:宋体">终止整个程序的运行。例如：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">void Func(void)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">A *a = new A;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">if(a == NULL)
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">{
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">cout &lt;&lt;?</span><span style="font-family:宋体">"</span><span style="font-family:Verdana">Memory Exhausted</span><span style="font-family:宋体">"</span><span style="font-family:Verdana">?&lt;&lt; endl;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">exit(1);
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">}
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　…</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　（</span><span style="font-family:Verdana">3</span><span style="font-family:宋体">）为</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">设置异常处理函数。例如</span><span style="font-family:Verdana">Visual C++</span><span style="font-family:宋体">可以用</span><span style="font-family:Verdana">_set_new_hander</span><span style="font-family:宋体">函数为</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">设置用户自己定义的异常处理函数，也可以让</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">享用与</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">相同的异常处理函数。详细内容请参考</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">使用手册。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　上述（</span><span style="font-family:Verdana">1</span><span style="font-family:宋体">）（</span><span style="font-family:Verdana">2</span><span style="font-family:宋体">）方式使用最普遍。如果一个函数内有多处需要申请动态内存，那么方式（</span><span style="font-family:Verdana">1</span><span style="font-family:宋体">）就显得力不从心（释放内存很麻烦），应该用方式（</span><span style="font-family:Verdana">2</span><span style="font-family:宋体">）来处理。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　很多人不忍心用</span><span style="font-family:Verdana">exit(1)</span><span style="font-family:宋体">，问："不编写出错处理程序，让操作系统自己解决行不行？"</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　不行。如果发生"内存耗尽"这样的事情，一般说来应用程序已经无药可救。如果不用</span><span style="font-family:Verdana">exit(1)</span><span style="font-family:宋体">把坏程序杀死，它可能会害死操作系统。道理如同：如果不把歹徒击毙，歹徒在老死之前会犯下更多的罪。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　有一个很重要的现象要告诉大家。对于</span><span style="font-family:Verdana">32</span><span style="font-family:宋体">位以上的应用程序而言，无论怎样使用</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">与</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">，几乎不可能导致"内存耗尽"。我在</span><span style="font-family:Verdana">Windows 98</span><span style="font-family:宋体">下用</span><span style="font-family:Verdana">Visual C++</span><span style="font-family:宋体">编写了测试程序，见示例</span><span style="font-family:Verdana">7</span><span style="font-family:宋体">。这个程序会无休止地运行下去，根本不会终止。因为</span><span style="font-family:Verdana">32</span><span style="font-family:宋体">位操作系统支持"虚存"，内存用完了，自动用硬盘空间顶替。我只听到硬盘嘎吱嘎吱地响，</span><span style="font-family:Verdana">Window 98</span><span style="font-family:宋体">已经累得对键盘、鼠标毫无反应。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　我可以得出这么一个结论：对于</span><span style="font-family:Verdana">32</span><span style="font-family:宋体">位以上的应用程序，"内存耗尽"错误处理程序毫无用处。这下可把</span><span style="font-family:Verdana">Unix</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">Windows</span><span style="font-family:宋体">程序员们乐坏了：反正错误处理程序不起作用，我就不写了，省了很多麻烦。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">我不想误导读者，必须强调：不加错误处理将导致程序的质量很差，千万不可因小失大。</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">void main(void)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">float *p = NULL;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">while(TRUE)
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">{
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">p = new float[1000000];
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">cout &lt;&lt;?</span><span style="font-family:宋体">"</span><span style="font-family:Verdana">eat memory</span><span style="font-family:宋体">"</span><span style="font-family:Verdana">?&lt;&lt; endl;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">if(p==NULL)
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　</span><span style="font-family:Verdana">exit(1);
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">}
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:15pt"><strong><span style="font-family:Verdana">1.1.9 malloc/free</span><span style="font-family:宋体">的使用要点</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">函数</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">的原型如下：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">void * malloc(size_t size);</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">用</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">申请一块长度为</span><span style="font-family:Verdana">length</span><span style="font-family:宋体">的整数类型的内存，程序如下：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">int *p = (int *) malloc(sizeof(int) * length);</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">我们应当把注意力集中在两个要素上："类型转换"和"</span><span style="font-family:Verdana">sizeof</span><span style="font-family:宋体">"。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:Verdana">* malloc</span><span style="font-family:宋体">返回值的类型是</span><span style="font-family:Verdana">void *</span><span style="font-family:宋体">，所以在调用</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">时要显式地进行类型转换，将</span><span style="font-family:Verdana">void *?</span><span style="font-family:宋体">转换成所需要的指针类型。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:Verdana">* malloc</span><span style="font-family:宋体">函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。我们通常记不住</span><span style="font-family:Verdana">int, float</span><span style="font-family:宋体">等数据类型的变量的确切字节数。例如</span><span style="font-family:Verdana">int</span><span style="font-family:宋体">变量在</span><span style="font-family:Verdana">16</span><span style="font-family:宋体">位系统下是</span><span style="font-family:Verdana">2</span><span style="font-family:宋体">个字节，在</span><span style="font-family:Verdana">32</span><span style="font-family:宋体">位下是</span><span style="font-family:Verdana">4</span><span style="font-family:宋体">个字节；而</span><span style="font-family:Verdana">float</span><span style="font-family:宋体">变量在</span><span style="font-family:Verdana">16</span><span style="font-family:宋体">位系统下是</span><span style="font-family:Verdana">4</span><span style="font-family:宋体">个字节，在</span><span style="font-family:Verdana">32</span><span style="font-family:宋体">位下也是</span><span style="font-family:Verdana">4</span><span style="font-family:宋体">个字节。最好用以下程序作一次测试：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">cout &lt;&lt; sizeof(char) &lt;&lt; endl;
</span></p><p><span style="font-family:Verdana; font-size:8pt">cout &lt;&lt; sizeof(int) &lt;&lt; endl;
</span></p><p><span style="font-family:Verdana; font-size:8pt">cout &lt;&lt; sizeof(unsigned int) &lt;&lt; endl;
</span></p><p><span style="font-family:Verdana; font-size:8pt">cout &lt;&lt; sizeof(long) &lt;&lt; endl;
</span></p><p><span style="font-family:Verdana; font-size:8pt">cout &lt;&lt; sizeof(unsigned long) &lt;&lt; endl;
</span></p><p><span style="font-family:Verdana; font-size:8pt">cout &lt;&lt; sizeof(float) &lt;&lt; endl;
</span></p><p><span style="font-family:Verdana; font-size:8pt">cout &lt;&lt; sizeof(double) &lt;&lt; endl;
</span></p><p><span style="font-family:Verdana; font-size:8pt">cout &lt;&lt; sizeof(void *) &lt;&lt; endl;</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">在</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">的"</span><span style="font-family:Verdana">()</span><span style="font-family:宋体">"中使用</span><span style="font-family:Verdana">sizeof</span><span style="font-family:宋体">运算符是良好的风格，但要当心有时我们会昏了头，写出</span><span style="font-family:Verdana">?p = malloc(sizeof(p))</span><span style="font-family:宋体">这样的程序来。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">函数</span><span style="font-family:Verdana">free</span><span style="font-family:宋体">的原型如下：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">void free( void * memblock );</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">为什么</span><span style="font-family:Verdana">free</span><span style="font-family:宋体">函数不象</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">函数那样复杂呢？这是因为指针</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">的类型以及它所指的内存的容量事先都是知道的，语句</span><span style="font-family:Verdana">free(p)</span><span style="font-family:宋体">能正确地释放内存。如果</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">是</span><span style="font-family:Verdana">NULL</span><span style="font-family:宋体">指针，那么</span><span style="font-family:Verdana">free</span><span style="font-family:宋体">对</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">无论操作多少次都不会出问题。如果</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">不是</span><span style="font-family:Verdana">NULL</span><span style="font-family:宋体">指针，那么</span><span style="font-family:Verdana">free</span><span style="font-family:宋体">对</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">连续操作两次就会导致程序运行错误。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:15pt"><strong><span style="font-family:Verdana">1.1.10 new/delete</span><span style="font-family:宋体">的使用要点</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">运算符</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">使用起来要比函数</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">简单得多，例如：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">int *p1 = (int *)malloc(sizeof(int) * length);
</span></p><p><span style="font-family:Verdana; font-size:8pt">int *p2 = new int[length];</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">这是因为</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">内置了</span><span style="font-family:Verdana">sizeof</span><span style="font-family:宋体">、类型转换和类型安全检查功能。对于非内部数据类型的对象而言，</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">在创建动态对象的同时完成了初始化工作。如果对象有多个构造函数，那么</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">的语句也可以有多种形式。例如</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">class Obj
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">public :
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">Obj(void); //?</span><span style="font-family:宋体">无参数的构造函数</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">Obj(int x); //?</span><span style="font-family:宋体">带一个参数的构造函数</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　…</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">void Test(void)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">Obj *a = new Obj;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">Obj *b = new Obj(1); //?</span><span style="font-family:宋体">初值为</span><span style="font-family:Verdana">1
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　…</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">delete a;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">delete b;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">如果用</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">创建对象数组，那么只能使用对象的无参数构造函数。例如：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-size:8pt"><span style="font-family:Verdana">Obj *objects = new Obj[100]; //?</span><span style="font-family:宋体">创建</span><span style="font-family:Verdana">100</span><span style="font-family:宋体">个动态对象</span></span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">不能写成：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-size:8pt"><span style="font-family:Verdana">Obj *objects = new Obj[100](1);//?</span><span style="font-family:宋体">创建</span><span style="font-family:Verdana">100</span><span style="font-family:宋体">个动态对象的同时赋初值</span><span style="font-family:Verdana">1</span></span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">在用</span><span style="font-family:Verdana">delete</span><span style="font-family:宋体">释放对象数组时，留意不要丢了符号'</span><span style="font-family:Verdana">[]</span><span style="font-family:宋体">'。例如：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-size:8pt"><span style="font-family:Verdana">delete []objects; //?</span><span style="font-family:宋体">正确的用法</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">delete objects; //?</span><span style="font-family:宋体">错误的用法</span></span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">后者有可能引起程序崩溃和内存泄漏。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:18pt"><strong><span style="font-family:Verdana">1.2 C++</span><span style="font-family:黑体">中的健壮指针和资源管理</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　我最喜欢的对资源的定义是：</span><span style="font-family:Verdana">"</span><span style="font-family:宋体">任何在你的程序中获得并在此后释放的东西</span><span style="font-family:Verdana">"</span><span style="font-family:宋体">。内存是一个相当明显的资源的例子。它需要用</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">来获得，用</span><span style="font-family:Verdana">delete</span><span style="font-family:宋体">来释放。同时也有许多其它类型的资源文件句柄、重要的片断、</span><span style="font-family:Verdana">Windows</span><span style="font-family:宋体">中的</span><span style="font-family:Verdana">GDI</span><span style="font-family:宋体">资源，等等。将资源的概念推广到程序中创建、释放的所有对象也是十分方便的，无论对象是在堆中分配的还是在栈中或者是在全局作用于内生命的。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">对于给定的资源的拥有着，是负责释放资源的一个对象或者是一段代码。所有权分立为两种级别——自动的和显式的（</span><span style="font-family:Verdana">automatic and explicit</span><span style="font-family:宋体">），如果一个对象的释放是由语言本身的机制来保证的，这个对象的就是被自动地所有。例如，一个嵌入在其他对象中的对象，他的清除需要其他对象来在清除的时候保证。外面的对象被看作嵌入类的所有者。</span><span style="font-family:Verdana">?</span><span style="font-family:宋体">　　
</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">类似地，每个在栈上创建的对象（作为自动变量）的释放（破坏）是在控制流离开了对象被定义的作用域的时候保证的。这种情况下，作用域被看作是对象的所有者。注意所有的自动所有权都是和语言的其他机制相容的，包括异常。无论是如何退出作用域的——正常流程控制退出、一个</span><span style="font-family:Verdana">break</span><span style="font-family:宋体">语句、一个</span><span style="font-family:Verdana">return</span><span style="font-family:宋体">、一个</span><span style="font-family:Verdana">goto</span><span style="font-family:宋体">、或者是一个</span><span style="font-family:Verdana">throw</span><span style="font-family:宋体">——自动资源都可以被清除。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　到目前为止，一切都很好！问题是在引入指针、句柄和抽象的时候产生的。如果通过一个指针访问一个对象的话，比如对象在堆中分配，</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">不自动地关注它的释放。程序员必须明确的用适当的程序方法来释放这些资源。比如说，如果一个对象是通过调用</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">来创建的，它需要用</span><span style="font-family:Verdana">delete</span><span style="font-family:宋体">来回收。一个文件是用</span><span style="font-family:Verdana">CreateFile(Win32 API)</span><span style="font-family:宋体">打开的，它需要用</span><span style="font-family:Verdana">CloseHandle</span><span style="font-family:宋体">来关闭。用</span><span style="font-family:Verdana">EnterCritialSection</span><span style="font-family:宋体">进入的临界区（</span><span style="font-family:Verdana">Critical Section</span><span style="font-family:宋体">）需要</span><span style="font-family:Verdana">LeaveCriticalSection</span><span style="font-family:宋体">退出，等等。一个</span><span style="font-family:Verdana">"</span><span style="font-family:宋体">裸</span><span style="font-family:Verdana">"</span><span style="font-family:宋体">指针，文件句柄，或者临界区状态没有所有者来确保它们的最终释放。基本的资源管理的前提就是确保每个资源都有他们的所有者。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:15pt"><strong><span style="font-family:Verdana">1.2.1?</span><span style="font-family:宋体">第一条规则（</span><span style="font-family:Verdana">RAII</span><span style="font-family:宋体">）</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　一个指针，一个句柄，一个临界区状态只有在我们将它们封装入对象的时候才会拥有所有者。<strong>这就是我们的第一规则：在构造函数中分配资源，在析构函数中释放资源。</strong></span><span style="font-family:Verdana"><strong>
				</strong></span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　当你按照规则将所有资源封装的时候，你可以保证你的程序中没有任何的资源泄露。这点在当封装对象（</span><span style="font-family:Verdana">Encapsulating Object</span><span style="font-family:宋体">）在栈中建立或者嵌入在其他的对象中的时候非常明显。但是对那些动态申请的对象呢？不要急！任何动态申请的东西都被看作一种资源，并且要按照上面提到的方法进行封装。这一对象封装对象的链不得不在某个地方终止。它最终终止在最高级的所有者，自动的或者是静态的。这些分别是对离开作用域或者程序时释放资源的保证。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　下面是资源封装的一个经典例子。在一个多线程的应用程序中，线程之间共享对象的问题是通过用这样一个对象联系临界区来解决的。每一个需要访问共享资源的客户需要获得临界区。例如，这可能是</span><span style="font-family:Verdana">Win32</span><span style="font-family:宋体">下临界区的实现方法。</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">class CritSect
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">friend class Lock;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">public:
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">CritSect () { InitializeCriticalSection (&amp;_critSection); }
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">~CritSect () { DeleteCriticalSection (&amp;_critSection); }
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">private:
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">void Acquire ()
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">{
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　</span><span style="font-family:Verdana">EnterCriticalSection (&amp;_critSection);
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">}
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">void Release ()
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">{
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　</span><span style="font-family:Verdana">LeaveCriticalSection (&amp;_critSection);
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">}
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">private:
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">CRITICAL_SECTION _critSection;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">};</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　这里聪明的部分是我们确保每一个进入临界区的客户最后都可以离开。</span><span style="font-family:Verdana">"</span><span style="font-family:宋体">进入</span><span style="font-family:Verdana">"</span><span style="font-family:宋体">临界区的状态是一种资源，并应当被封装。封装器通常被称作一个锁（</span><span style="font-family:Verdana">lock</span><span style="font-family:宋体">）。</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">class Lock
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">public:
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">Lock (CritSect&amp; critSect) : _critSect (critSect)
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">{
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　</span><span style="font-family:Verdana">_critSect.Acquire ();
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">}
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">~Lock ()
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">{
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　</span><span style="font-family:Verdana">_critSect.Release ();
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">}
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">private
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">CritSect &amp; _critSect;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">};</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　锁一般的用法如下：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">void Shared::Act () throw (char *)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">Lock lock (_critSect);
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">// perform action?</span><span style="font-family:宋体">——</span><span style="font-family:Verdana">?may throw
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">// automatic destructor of lock
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　注意无论发生什么，临界区都会借助于语言的机制保证释放。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　还有一件需要记住的事情——每一种资源都需要被分别封装。这是因为资源分配是一个非常容易出错的操作，是要资源是有限提供的。我们会假设一个失败的资源分配会导致一个异常——事实上，这会经常的发生。所以如果你想试图用一个石头打两只鸟的话，或者在一个构造函数中申请两种形式的资源，你可能就会陷入麻烦。只要想想在一种资源分配成功但另一种失败抛出异常时会发生什么。因为构造函数还没有全部完成，析构函数不可能被调用，第一种资源就会发生泄露。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">这种情况可以非常简单的避免。无论何时你有一个需要两种以上资源的类时，写两个小的封装器将它们嵌入你的类中。每一个嵌入的构造都可以保证删除，即使包装类没有构造完成。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-family:Verdana; font-size:15pt"><strong>1.2.2 Smart Pointers
</strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　我们至今还没有讨论最常见类型的资源——用操作符</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">分配，此后用指针访问的一个对象。我们需要为每个对象分别定义一个封装类吗？（事实上，</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">标准模板库已经有了一个模板类，叫做</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">，其作用就是提供这种封装。我们一会儿在回到</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">。）让我们从一个极其简单、呆板但安全的东西开始。看下面的</span><span style="font-family:Verdana">Smart Pointer</span><span style="font-family:宋体">模板类，它十分坚固，甚至无法实现。</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">template &lt;class T&gt;
</span></p><p><span style="font-family:Verdana; font-size:8pt">class SmartPointer
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">public:
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">~SmartPointer () { delete _p; }
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">T * operator-&gt;() { return _p; }
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">T const * operator-&gt;() const { return _p; }
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">protected:
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">SmartPointer (): _p (0) {}
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">explicit SmartPointer (T* p): _p (p) {}
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">T * _p;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">};</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　为什么要把</span><span style="font-family:Verdana">SmartPointer</span><span style="font-family:宋体">的构造函数设计为</span><span style="font-family:Verdana">protected</span><span style="font-family:宋体">呢？如果我需要遵守第一条规则，那么我就必须这样做。资源——在这里是</span><span style="font-family:Verdana">class T</span><span style="font-family:宋体">的一个对象——必须在封装器的构造函数中分配。但是我不能只简单的调用</span><span style="font-family:Verdana">new T</span><span style="font-family:宋体">，因为我不知道</span><span style="font-family:Verdana">T</span><span style="font-family:宋体">的构造函数的参数。因为，在原则上，每一个</span><span style="font-family:Verdana">T</span><span style="font-family:宋体">都有一个不同的构造函数；我需要为他定义个另外一个封装器。模板的用处会很大，为每一个新的类，我可以通过继承</span><span style="font-family:Verdana">SmartPointer</span><span style="font-family:宋体">定义一个新的封装器，并且提供一个特定的构造函数。</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">class SmartItem: public SmartPointer&lt;Item&gt;
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">public:
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">explicit SmartItem (int i)
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">: SmartPointer&lt;Item&gt; (new Item (i)) {}
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">};</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　为每一个类提供一个</span><span style="font-family:Verdana">Smart Pointer</span><span style="font-family:宋体">真的值得吗？说实话——不！他很有教学的价值，但是一旦你学会如何遵循第一规则的话，你就可以放松规则并使用一些高级的技术。这一技术是让</span><span style="font-family:Verdana">SmartPointer</span><span style="font-family:宋体">的构造函数成为</span><span style="font-family:Verdana">public</span><span style="font-family:宋体">，但是只是是用它来做资源转换（</span><span style="font-family:Verdana">Resource Transfer</span><span style="font-family:宋体">）我的意思是用</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">操作符的结果直接作为</span><span style="font-family:Verdana">SmartPointer</span><span style="font-family:宋体">的构造函数的参数，像这样：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">SmartPointer&lt;Item&gt; item (new Item (i));</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　这个方法明显更需要自控性，不只是你，而且包括你的程序小组的每个成员。他们都必须发誓除了作资源转换外不把构造函数用在任意其他用途。幸运的是，这条规矩很容易得以加强。只需要在源文件中查找所有的</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">即可。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-family:Verdana; font-size:15pt"><strong>1.2.3 Resource Transfer
</strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　到目前为止，我们所讨论的一直是生命周期在一个单独的作用域内的资源。现在我们要解决一个困难的问题——如何在不同的作用域间安全的传递资源。这一问题在当你处理容器的时候会变得十分明显。你可以动态的创建一串对象，将它们存放至一个容器中，然后将它们取出，并且在最终安排它们。为了能够让这安全的工作——没有泄露——对象需要改变其所有者。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　这个问题的一个非常显而易见的解决方法是使用</span><span style="font-family:Verdana">Smart Pointer</span><span style="font-family:宋体">，无论是在加入容器前还是还找到它们以后。这是他如何运作的，你加入</span><span style="font-family:Verdana">Release</span><span style="font-family:宋体">方法到</span><span style="font-family:Verdana">Smart Pointer</span><span style="font-family:宋体">中：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">template &lt;class T&gt;
</span></p><p><span style="font-family:Verdana; font-size:8pt">T * SmartPointer&lt;T&gt;::Release ()
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">T * pTmp = _p;
</span></p><p><span style="font-family:Verdana; font-size:8pt">_p = 0;
</span></p><p><span style="font-family:Verdana; font-size:8pt">return pTmp;
</span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　注意在</span><span style="font-family:Verdana">Release</span><span style="font-family:宋体">调用以后，</span><span style="font-family:Verdana">Smart Pointer</span><span style="font-family:宋体">就不再是对象的所有者了——它内部的指针指向空。现在，调用了</span><span style="font-family:Verdana">Release</span><span style="font-family:宋体">都必须是一个负责的人并且迅速隐藏返回的指针到新的所有者对象中。在我们的例子中，容器调用了</span><span style="font-family:Verdana">Release</span><span style="font-family:宋体">，比如这个</span><span style="font-family:Verdana">Stack</span><span style="font-family:宋体">的例子：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">void Stack::Push (SmartPointer &lt;Item&gt; &amp; item) throw (char *)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">if (_top == maxStack)
</span></p><p><span style="font-family:Verdana; font-size:8pt">throw "Stack overflow";
</span></p><p><span style="font-family:Verdana; font-size:8pt">_arr [_top++] = item.Release ();
</span></p><p><span style="font-family:Verdana; font-size:8pt">};</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　同样的，你也可以再你的代码中用加强</span><span style="font-family:Verdana">Release</span><span style="font-family:宋体">的可靠性。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">相应的</span><span style="font-family:Verdana">Pop</span><span style="font-family:宋体">方法要做些什么呢？他应该释放了资源并祈祷调用它的是一个负责的人而且立即作一个资源传递它到一个</span><span style="font-family:Verdana">Smart Pointer</span><span style="font-family:宋体">？这听起来并不好。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-family:Verdana; font-size:8pt"><strong>1.2.4 Strong Pointers
</strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　资源管理在内容索引（</span><span style="font-family:Verdana">Windows NT Server</span><span style="font-family:宋体">上的一部分，现在是</span><span style="font-family:Verdana">Windows 2000</span><span style="font-family:宋体">）上工作，并且，我对这十分满意。然后我开始想……这一方法是在这样一个完整的系统中形成的，如果可以把它内建入语言的本身岂不是一件非常好？我提出了强指针（</span><span style="font-family:Verdana">Strong Pointer</span><span style="font-family:宋体">）和弱指针</span><span style="font-family:Verdana">(Weak Pointer)</span><span style="font-family:宋体">。一个</span><span style="font-family:Verdana">Strong Pointer</span><span style="font-family:宋体">会在许多地方和我们这个</span><span style="font-family:Verdana">SmartPointer</span><span style="font-family:宋体">相似</span><span style="font-family:Verdana">--</span><span style="font-family:宋体">它在超出它的作用域后会清除他所指向的对象。资源传递会以强指针赋值的形式进行。也可以有</span><span style="font-family:Verdana">Weak Pointer</span><span style="font-family:宋体">存在，它们用来访问对象而不需要所有对象</span><span style="font-family:Verdana">--</span><span style="font-family:宋体">比如可赋值的引用。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　任何指针都必须声明为</span><span style="font-family:Verdana">Strong</span><span style="font-family:宋体">或者</span><span style="font-family:Verdana">Weak</span><span style="font-family:宋体">，并且语言应该来关注类型转换的规定。例如，你不可以将</span><span style="font-family:Verdana">Weak Pointer</span><span style="font-family:宋体">传递到一个需要</span><span style="font-family:Verdana">Strong Pointer</span><span style="font-family:宋体">的地方，但是相反却可以。</span><span style="font-family:Verdana">Push</span><span style="font-family:宋体">方法可以接受一个</span><span style="font-family:Verdana">Strong Pointer</span><span style="font-family:宋体">并且将它转移到</span><span style="font-family:Verdana">Stack</span><span style="font-family:宋体">中的</span><span style="font-family:Verdana">Strong Pointer</span><span style="font-family:宋体">的序列中。</span><span style="font-family:Verdana">Pop</span><span style="font-family:宋体">方法将会返回一个</span><span style="font-family:Verdana">Strong Pointer</span><span style="font-family:宋体">。把</span><span style="font-family:Verdana">Strong Pointer</span><span style="font-family:宋体">的引入语言将会使垃圾回收成为历史。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　这里还有一个小问题</span><span style="font-family:Verdana">--</span><span style="font-family:宋体">修改</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">标准几乎和竞选美国总统一样容易。当我将我的注意告诉给</span><span style="font-family:Verdana">Bjarne Stroutrup</span><span style="font-family:宋体">的时候，他看我的眼神好像是我刚刚要向他借一千美元一样。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">然后我突然想到一个念头。我可以自己实现</span><span style="font-family:Verdana">Strong Pointers</span><span style="font-family:宋体">。毕竟，它们都很想</span><span style="font-family:Verdana">Smart Pointers</span><span style="font-family:宋体">。给它们一个拷贝构造函数并重载赋值操作符并不是一个大问题。事实上，这正是标准库中的</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">有的。重要的是对这些操作给出一个资源转移的语法，但是这也不是很难。</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">template &lt;class T&gt;
</span></p><p><span style="font-family:Verdana; font-size:8pt">SmartPointer&lt;T&gt;::SmartPointer (SmartPointer&lt;T&gt; &amp; ptr)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">_p = ptr.Release ();
</span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">template &lt;class T&gt;
</span></p><p><span style="font-family:Verdana; font-size:8pt">void SmartPointer&lt;T&gt;::operator = (SmartPointer&lt;T&gt; &amp; ptr)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">if (_p != ptr._p)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">delete _p;
</span></p><p><span style="font-family:Verdana; font-size:8pt">_p = ptr.Release ();
</span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　使这整个想法迅速成功的原因之一是我可以以值方式传递这种封装指针！我有了我的蛋糕，并且也可以吃了。看这个</span><span style="font-family:Verdana">Stack</span><span style="font-family:宋体">的新的实现：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">class Stack
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">enum { maxStack = 3 };
</span></p><p><span style="font-family:Verdana; font-size:8pt">public:
</span></p><p><span style="font-family:Verdana; font-size:8pt">Stack ()
</span></p><p><span style="font-family:Verdana; font-size:8pt">: _top (0)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{}
</span></p><p><span style="font-family:Verdana; font-size:8pt">void Push (SmartPointer&lt;Item&gt; &amp; item) throw (char *)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">if (_top &gt;= maxStack)
</span></p><p><span style="font-family:Verdana; font-size:8pt">throw "Stack overflow";
</span></p><p><span style="font-family:Verdana; font-size:8pt">_arr [_top++] = item;
</span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">SmartPointer&lt;Item&gt; Pop ()
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">if (_top == 0)
</span></p><p><span style="font-family:Verdana; font-size:8pt">return SmartPointer&lt;Item&gt; ();
</span></p><p><span style="font-family:Verdana; font-size:8pt">return _arr [--_top];
</span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">private
</span></p><p><span style="font-family:Verdana; font-size:8pt">int _top;
</span></p><p><span style="font-family:Verdana; font-size:8pt">SmartPointer&lt;Item&gt; _arr [maxStack];
</span></p><p><span style="font-family:Verdana; font-size:8pt">};</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">Pop</span><span style="font-family:宋体">方法强制客户将其返回值赋给一个</span><span style="font-family:Verdana">Strong Pointer,SmartPointer&lt;Item&gt;</span><span style="font-family:宋体">。任何试图将他对一个普通指针的赋值都会产生一个编译期错误，因为类型不匹配。此外，因为</span><span style="font-family:Verdana">Pop</span><span style="font-family:宋体">以值方式返回一个</span><span style="font-family:Verdana">Strong Pointer(</span><span style="font-family:宋体">在</span><span style="font-family:Verdana">Pop</span><span style="font-family:宋体">的声明时</span><span style="font-family:Verdana">SmartPointer&lt;Item&gt;</span><span style="font-family:宋体">后面没有</span><span style="font-family:Verdana">&amp;</span><span style="font-family:宋体">符号</span><span style="font-family:Verdana">)</span><span style="font-family:宋体">，编译器在</span><span style="font-family:Verdana">return</span><span style="font-family:宋体">时自动进行了一个资源转换。他调用了</span><span style="font-family:Verdana">operator =</span><span style="font-family:宋体">来从数组中提取一个</span><span style="font-family:Verdana">Item,</span><span style="font-family:宋体">拷贝构造函数将他传递给调用者。调用者最后拥有了指向</span><span style="font-family:Verdana">Pop</span><span style="font-family:宋体">赋值的</span><span style="font-family:Verdana">Strong Pointer</span><span style="font-family:宋体">指向的一个</span><span style="font-family:Verdana">Item</span><span style="font-family:宋体">。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">我马上意识到我已经在某些东西之上了。我开始用了新的方法重写原来的代码。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-family:Verdana; font-size:8pt"><strong>1.2.5 Parser
</strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">我过去有一个老的算术操作分析器，是用老的资源管理的技术写的。分析器的作用是在分析树中生成节点，节点是动态分配的。例如分析器的</span><span style="font-family:Verdana">Expression</span><span style="font-family:宋体">方法生成一个表达式节点。我没有时间用</span><span style="font-family:Verdana">Strong Pointer</span><span style="font-family:宋体">去重写这个分析器。我令</span><span style="font-family:Verdana">Expression</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">Term</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">Factor</span><span style="font-family:宋体">方法以传值的方式将</span><span style="font-family:Verdana">Strong Pointer</span><span style="font-family:宋体">返回到</span><span style="font-family:Verdana">Node</span><span style="font-family:宋体">中。看下面的</span><span style="font-family:Verdana">Expression</span><span style="font-family:宋体">方法的实现：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">SmartPointer&lt;Node&gt; Parser::Expression()
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">// Parse a term
</span></p><p><span style="font-family:Verdana; font-size:8pt">SmartPointer&lt;Node&gt; pNode = Term ();
</span></p><p><span style="font-family:Verdana; font-size:8pt">EToken token = _scanner.Token();
</span></p><p><span style="font-family:Verdana; font-size:8pt">if ( token == tPlus || token == tMinus )
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">// Expr := Term { ('+' | '-') Term }
</span></p><p><span style="font-family:Verdana; font-size:8pt">SmartPointer&lt;MultiNode&gt; pMultiNode = new SumNode (pNode);
</span></p><p><span style="font-family:Verdana; font-size:8pt">do
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">_scanner.Accept();
</span></p><p><span style="font-family:Verdana; font-size:8pt">SmartPointer&lt;Node&gt; pRight = Term ();
</span></p><p><span style="font-family:Verdana; font-size:8pt">pMultiNode-&gt;AddChild (pRight, (token == tPlus));
</span></p><p><span style="font-family:Verdana; font-size:8pt">token = _scanner.Token();
</span></p><p><span style="font-family:Verdana; font-size:8pt">} while (token == tPlus || token == tMinus);
</span></p><p><span style="font-family:Verdana; font-size:8pt">pNode = up_cast&lt;Node, MultiNode&gt; (pMultiNode);
</span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">// otherwise Expr := Term
</span></p><p><span style="font-family:Verdana; font-size:8pt">return pNode; // by value!
</span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　最开始，</span><span style="font-family:Verdana">Term</span><span style="font-family:宋体">方法被调用。他传值返回一个指向</span><span style="font-family:Verdana">Node</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">Strong Pointer</span><span style="font-family:宋体">并且立刻把它保存到我们自己的</span><span style="font-family:Verdana">Strong Pointer,pNode</span><span style="font-family:宋体">中。如果下一个符号不是加号或者减号，我们就简单的把这个</span><span style="font-family:Verdana">SmartPointer</span><span style="font-family:宋体">以值返回，这样就释放了</span><span style="font-family:Verdana">Node</span><span style="font-family:宋体">的所有权。另外一方面，如果下一个符号是加号或者减号，我们创建一个新的</span><span style="font-family:Verdana">SumMode</span><span style="font-family:宋体">并且立刻（直接传递）将它储存到</span><span style="font-family:Verdana">MultiNode</span><span style="font-family:宋体">的一个</span><span style="font-family:Verdana">Strong Pointer</span><span style="font-family:宋体">中。这里，</span><span style="font-family:Verdana">SumNode</span><span style="font-family:宋体">是从</span><span style="font-family:Verdana">MultiMode</span><span style="font-family:宋体">中继承而来的，而</span><span style="font-family:Verdana">MulitNode</span><span style="font-family:宋体">是从</span><span style="font-family:Verdana">Node</span><span style="font-family:宋体">继承而来的。原来的</span><span style="font-family:Verdana">Node</span><span style="font-family:宋体">的所有权转给了</span><span style="font-family:Verdana">SumNode</span><span style="font-family:宋体">。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　只要是他们在被加号和减号分开的时候，我们就不断的创建</span><span style="font-family:Verdana">terms</span><span style="font-family:宋体">，我们将这些</span><span style="font-family:Verdana">term</span><span style="font-family:宋体">转移到我们的</span><span style="font-family:Verdana">MultiNode</span><span style="font-family:宋体">中，同时</span><span style="font-family:Verdana">MultiNode</span><span style="font-family:宋体">得到了所有权。最后，我们将指向</span><span style="font-family:Verdana">MultiNode</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">Strong Pointer</span><span style="font-family:宋体">向上映射为指向</span><span style="font-family:Verdana">Mode</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">Strong Pointer</span><span style="font-family:宋体">，并且将他返回调用着。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　我们需要对</span><span style="font-family:Verdana">Strong Pointers</span><span style="font-family:宋体">进行显式的向上映射，即使指针是被隐式的封装。例如，一个</span><span style="font-family:Verdana">MultiNode</span><span style="font-family:宋体">是一个</span><span style="font-family:Verdana">Node</span><span style="font-family:宋体">，但是相同的</span><span style="font-family:Verdana">is-a</span><span style="font-family:宋体">关系在</span><span style="font-family:Verdana">SmartPointer&lt;MultiNode&gt;</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">SmartPointer&lt;Node&gt;</span><span style="font-family:宋体">之间并不存在，因为它们是分离的类（模板实例）并不存在继承关系。</span><span style="font-family:Verdana">up-cast</span><span style="font-family:宋体">模板是像下面这样定义的：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">template&lt;class To, class From&gt;
</span></p><p><span style="font-family:Verdana; font-size:8pt">inline SmartPointer&lt;To&gt; up_cast (SmartPointer&lt;From&gt; &amp; from)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">return SmartPointer&lt;To&gt; (from.Release ());
</span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　如果你的编译器支持新加入标准的成员模板（</span><span style="font-family:Verdana">member template</span><span style="font-family:宋体">）的话，你可以为</span><span style="font-family:Verdana">SmartPointer&lt;T&gt;</span><span style="font-family:宋体">定义一个新的构造函数用来从接受一个</span><span style="font-family:Verdana">class U</span><span style="font-family:宋体">。</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">template &lt;class T&gt;
</span></p><p><span style="font-family:Verdana; font-size:8pt">template &lt;class U&gt; SmartPointer&lt;T&gt;::SmartPointer (SPrt&lt;U&gt; &amp; uptr)
</span></p><p><span style="font-family:Verdana; font-size:8pt">: _p (uptr.Release ())
</span></p><p><span style="font-family:Verdana; font-size:8pt">{}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　这里的这个花招是模板在</span><span style="font-family:Verdana">U</span><span style="font-family:宋体">不是</span><span style="font-family:Verdana">T</span><span style="font-family:宋体">的子类的时候就不会编译成功（换句话说，只在</span><span style="font-family:Verdana">U is-a T</span><span style="font-family:宋体">的时候才会编译）。这是因为</span><span style="font-family:Verdana">uptr</span><span style="font-family:宋体">的缘故。</span><span style="font-family:Verdana">Release()</span><span style="font-family:宋体">方法返回一个指向</span><span style="font-family:Verdana">U</span><span style="font-family:宋体">的指针，并被赋值为</span><span style="font-family:Verdana">_p</span><span style="font-family:宋体">，一个指向</span><span style="font-family:Verdana">T</span><span style="font-family:宋体">的指针。所以如果</span><span style="font-family:Verdana">U</span><span style="font-family:宋体">不是一个</span><span style="font-family:Verdana">T</span><span style="font-family:宋体">的话，赋值会导致一个编译时刻错误。</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">std::auto_ptr</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">后来我意识到在</span><span style="font-family:Verdana">STL</span><span style="font-family:宋体">中的</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">模板，就是我的</span><span style="font-family:Verdana">Strong Pointer</span><span style="font-family:宋体">。在那时候还有许多的实现差异（</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">Release</span><span style="font-family:宋体">方法并不将内部的指针清零</span><span style="font-family:Verdana">--</span><span style="font-family:宋体">你的编译器的库很可能用的就是这种陈旧的实现），但是最后在标准被广泛接受之前都被解决了。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-family:Verdana; font-size:8pt"><strong>1.2.6 Transfer Semantics
</strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　目前为止，我们一直在讨论在</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">程序中资源管理的方法。宗旨是将资源封装到一些轻量级的类中，并由类负责它们的释放。特别的是，所有用</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">操作符分配的资源都会被储存并传递进</span><span style="font-family:Verdana">Strong Pointer</span><span style="font-family:宋体">（标准库中的</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">）的内部。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　这里的关键词是传递（</span><span style="font-family:Verdana">passing</span><span style="font-family:宋体">）。一个容器可以通过传值返回一个</span><span style="font-family:Verdana">Strong Pointer</span><span style="font-family:宋体">来安全的释放资源。容器的客户只能够通过提供一个相应的</span><span style="font-family:Verdana">Strong Pointer</span><span style="font-family:宋体">来保存这个资源。任何一个将结果赋给一个</span><span style="font-family:Verdana">"</span><span style="font-family:宋体">裸</span><span style="font-family:Verdana">"</span><span style="font-family:宋体">指针的做法都立即会被编译器发现。</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">auto_ptr&lt;Item&gt; item = stack.Pop (); // ok
</span></p><p><span style="font-family:Verdana; font-size:8pt">Item * p = stack.Pop (); // Error! Type mismatch.</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　以传值方式被传递的对象有</span><span style="font-family:Verdana">value semantics?</span><span style="font-family:宋体">或者称为</span><span style="font-family:Verdana">?copy semantics</span><span style="font-family:宋体">。</span><span style="font-family:Verdana">Strong Pointers</span><span style="font-family:宋体">是以值方式传递的</span><span style="font-family:Verdana">--</span><span style="font-family:宋体">但是我们能说它们有</span><span style="font-family:Verdana">copy semantics</span><span style="font-family:宋体">吗？不是这样的！它们所指向的对象肯定没有被拷贝过。事实上，传递过后，源</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">不在访问原有的对象，并且目标</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">成为了对象的唯一拥有者（但是往往</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">的旧的实现即使在释放后仍然保持着对对象的所有权）。自然而然的我们可以将这种新的行为称作</span><span style="font-family:Verdana">Transfer Semantics</span><span style="font-family:宋体">。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　拷贝构造函数（</span><span style="font-family:Verdana">copy construcor</span><span style="font-family:宋体">）和赋值操作符定义了</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">Transfer Semantics</span><span style="font-family:宋体">，它们用了非</span><span style="font-family:Verdana">const</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">引用作为它们的参数。</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">auto_ptr (auto_ptr&lt;T&gt; &amp; ptr);
</span></p><p><span style="font-family:Verdana; font-size:8pt">auto_ptr &amp; operator = (auto_ptr&lt;T&gt; &amp; ptr);</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　这是因为它们确实改变了他们的源</span><span style="font-family:Verdana">--</span><span style="font-family:宋体">剥夺了对资源的所有权。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">通过定义相应的拷贝构造函数和重载赋值操作符，你可以将</span><span style="font-family:Verdana">Transfer Semantics</span><span style="font-family:宋体">加入到许多对象中。例如，许多</span><span style="font-family:Verdana">Windows</span><span style="font-family:宋体">中的资源，比如动态建立的菜单或者位图，可以用有</span><span style="font-family:Verdana">Transfer Semantics</span><span style="font-family:宋体">的类来封装。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-family:Verdana; font-size:8pt"><strong>1.2.7 Strong Vectors
</strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　标准库只在</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">中支持资源管理。甚至连最简单的容器也不支持</span><span style="font-family:Verdana">ownership semantics</span><span style="font-family:宋体">。你可能想将</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">和标准容器组合到一起可能会管用，但是并不是这样的。例如，你可能会这样做，但是会发现你不能够用标准的方法来进行索引。</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">vector&lt; auto_ptr&lt;Item&gt; &gt; autoVector;</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　这种建造不会编译成功；</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">Item * item = autoVector [0];</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　另一方面，这会导致一个从</span><span style="font-family:Verdana">autoVect</span><span style="font-family:宋体">到</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">的所有权转换：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">auto_ptr&lt;Item&gt; item = autoVector [0];</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　我们没有选择，只能够构造我们自己的</span><span style="font-family:Verdana">Strong Vector</span><span style="font-family:宋体">。最小的接口应该如下：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">template &lt;class T&gt;
</span></p><p><span style="font-family:Verdana; font-size:8pt">class auto_vector
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">public:
</span></p><p><span style="font-family:Verdana; font-size:8pt">explicit auto_vector (size_t capacity = 0);
</span></p><p><span style="font-family:Verdana; font-size:8pt">T const * operator [] (size_t i) const;
</span></p><p><span style="font-family:Verdana; font-size:8pt">T * operator [] (size_t i);
</span></p><p><span style="font-family:Verdana; font-size:8pt">void assign (size_t i, auto_ptr&lt;T&gt; &amp; p);
</span></p><p><span style="font-family:Verdana; font-size:8pt">void assign_direct (size_t i, T * p);
</span></p><p><span style="font-family:Verdana; font-size:8pt">void push_back (auto_ptr&lt;T&gt; &amp; p);
</span></p><p><span style="font-family:Verdana; font-size:8pt">auto_ptr&lt;T&gt; pop_back ();
</span></p><p><span style="font-family:Verdana; font-size:8pt">};</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　你也许会发现一个非常防御性的设计态度。我决定不提供一个对</span><span style="font-family:Verdana">vector</span><span style="font-family:宋体">的左值索引的访问，取而代之，如果你想设定</span><span style="font-family:Verdana">(set)</span><span style="font-family:宋体">一个值的话，你必须用</span><span style="font-family:Verdana">assign</span><span style="font-family:宋体">或者</span><span style="font-family:Verdana">assign_direct</span><span style="font-family:宋体">方法。我的观点是，资源管理不应该被忽视，同时，也不应该在所有的地方滥用。在我的经验里，一个</span><span style="font-family:Verdana">strong vector</span><span style="font-family:宋体">经常被许多</span><span style="font-family:Verdana">push_back</span><span style="font-family:宋体">方法充斥着。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">Strong vector</span><span style="font-family:宋体">最好用一个动态的</span><span style="font-family:Verdana">Strong Pointers</span><span style="font-family:宋体">的数组来实现：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">template &lt;class T&gt;
</span></p><p><span style="font-family:Verdana; font-size:8pt">class auto_vector
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">private
</span></p><p><span style="font-family:Verdana; font-size:8pt">void grow (size_t reqCapacity);
</span></p><p><span style="font-family:Verdana; font-size:8pt">auto_ptr&lt;T&gt; *_arr;
</span></p><p><span style="font-family:Verdana; font-size:8pt">size_t _capacity;
</span></p><p><span style="font-family:Verdana; font-size:8pt">size_t _end;
</span></p><p><span style="font-family:Verdana; font-size:8pt">};</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">grow</span><span style="font-family:宋体">方法申请了一个很大的</span><span style="font-family:Verdana">auto_ptr&lt;T&gt;</span><span style="font-family:宋体">的数组，将所有的东西从老的书组类转移出来，在其中交换，并且删除原来的数组。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">auto_vector</span><span style="font-family:宋体">的其他实现都是十分直接的，因为所有资源管理的复杂度都在</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">中。例如，</span><span style="font-family:Verdana">assign</span><span style="font-family:宋体">方法简单的利用了重载的赋值操作符来删除原有的对象并转移资源到新的对象：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">void assign (size_t i, auto_ptr&lt;T&gt; &amp; p)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">_arr [i] = p;
</span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　我已经讨论了</span><span style="font-family:Verdana">push_back</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">pop_back</span><span style="font-family:宋体">方法。</span><span style="font-family:Verdana">push_back</span><span style="font-family:宋体">方法传值返回一个</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">，因为它将所有权从</span><span style="font-family:Verdana">auto_vector</span><span style="font-family:宋体">转换到</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">中。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　对</span><span style="font-family:Verdana">auto_vector</span><span style="font-family:宋体">的索引访问是借助</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">get</span><span style="font-family:宋体">方法来实现的，</span><span style="font-family:Verdana">get</span><span style="font-family:宋体">简单的返回一个内部指针。</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">T * operator [] (size_t i)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">return _arr [i].get ();
</span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　没有容器可以没有</span><span style="font-family:Verdana">iterator</span><span style="font-family:宋体">。我们需要一个</span><span style="font-family:Verdana">iterator</span><span style="font-family:宋体">让</span><span style="font-family:Verdana">auto_vector</span><span style="font-family:宋体">看起来更像一个普通的指针向量。特别是，当我们废弃</span><span style="font-family:Verdana">iterator</span><span style="font-family:宋体">的时候，我们需要的是一个指针而不是</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">。我们不希望一个</span><span style="font-family:Verdana">auto_vector</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">iterator</span><span style="font-family:宋体">在无意中进行资源转换。</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">template&lt;class T&gt;
</span></p><p><span style="font-family:Verdana; font-size:8pt">class auto_iterator: public
</span></p><p><span style="font-family:Verdana; font-size:8pt">iterator&lt;random_access_iterator_tag, T *&gt;
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">public:
</span></p><p><span style="font-family:Verdana; font-size:8pt">auto_iterator () : _pp (0) {}
</span></p><p><span style="font-family:Verdana; font-size:8pt">auto_iterator (auto_ptr&lt;T&gt; * pp) : _pp (pp) {}
</span></p><p><span style="font-family:Verdana; font-size:8pt">bool operator != (auto_iterator&lt;T&gt; const &amp; it) const
</span></p><p><span style="font-family:Verdana; font-size:8pt">{ return it._pp != _pp; }
</span></p><p><span style="font-family:Verdana; font-size:8pt">auto_iterator const &amp; operator++ (int) { return _pp++; }
</span></p><p><span style="font-family:Verdana; font-size:8pt">auto_iterator operator++ () { return ++_pp; }
</span></p><p><span style="font-family:Verdana; font-size:8pt">T * operator * () { return _pp-&gt;get (); }
</span></p><p><span style="font-family:Verdana; font-size:8pt">private
</span></p><p><span style="font-family:Verdana; font-size:8pt">auto_ptr&lt;T&gt; * _pp;
</span></p><p><span style="font-family:Verdana; font-size:8pt">};</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">我们给</span><span style="font-family:Verdana">auto_vect</span><span style="font-family:宋体">提供了标准的</span><span style="font-family:Verdana">begin</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">end</span><span style="font-family:宋体">方法来找回</span><span style="font-family:Verdana">iterator</span><span style="font-family:宋体">：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">class auto_vector
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">public:
</span></p><p><span style="font-family:Verdana; font-size:8pt">typedef auto_iterator&lt;T&gt; iterator;
</span></p><p><span style="font-family:Verdana; font-size:8pt">iterator begin () { return _arr; }
</span></p><p><span style="font-family:Verdana; font-size:8pt">iterator end () { return _arr + _end; }
</span></p><p><span style="font-family:Verdana; font-size:8pt">};?</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　你也许会问我们是否要利用资源管理重新实现每一个标准的容器？幸运的是，不</span><span style="font-family:Verdana">;</span><span style="font-family:宋体">事实是</span><span style="font-family:Verdana">strong vector</span><span style="font-family:宋体">解决了大部分所有权的需求。当你把你的对象都安全的放置到一个</span><span style="font-family:Verdana">strong vector</span><span style="font-family:宋体">中，你可以用所有其它的容器来重新安排（</span><span style="font-family:Verdana">weak</span><span style="font-family:宋体">）</span><span style="font-family:Verdana">pointer</span><span style="font-family:宋体">。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">设想，例如，你需要对一些动态分配的对象排序的时候。你将它们的指针保存到一个</span><span style="font-family:Verdana">strong vector</span><span style="font-family:宋体">中。然后你用一个标准的</span><span style="font-family:Verdana">vector</span><span style="font-family:宋体">来保存从</span><span style="font-family:Verdana">strong vector</span><span style="font-family:宋体">中获得的</span><span style="font-family:Verdana">weak</span><span style="font-family:宋体">指针。你可以用标准的算法对这个</span><span style="font-family:Verdana">vector</span><span style="font-family:宋体">进行排序。这种中介</span><span style="font-family:Verdana">vector</span><span style="font-family:宋体">叫做</span><span style="font-family:Verdana">permutation vector</span><span style="font-family:宋体">。相似的，你也可以用标准的</span><span style="font-family:Verdana">maps, priority queues, heaps, hash tables</span><span style="font-family:宋体">等等。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-family:Verdana; font-size:8pt"><strong>1.2.8 Code Inspection
</strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　如果你严格遵照资源管理的条款，你就不会再资源泄露或者两次删除的地方遇到麻烦。你也降低了访问野指针的几率。同样的，遵循原有的规则，用</span><span style="font-family:Verdana">delete</span><span style="font-family:宋体">删除用</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">申请的指针，不要两次删除一个指针。你也不会遇到麻烦。但是，那个是更好的注意呢？</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　这两个方法有一个很大的不同点。就是和寻找传统方法的</span><span style="font-family:Verdana">bug</span><span style="font-family:宋体">相比，找到违反资源管理的规定要容易的多。后者仅需要一个代码检测或者一个运行测试，而前者则在代码中隐藏得很深，并需要很深的检查。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　设想你要做一段传统的代码的内存泄露检查。第一件事，你要做的就是</span><span style="font-family:Verdana">grep</span><span style="font-family:宋体">所有在代码中出现的</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">，你需要找出被分配空间地指针都作了什么。你需要确定导致删除这个指针的所有的执行路径。你需要检查</span><span style="font-family:Verdana">break</span><span style="font-family:宋体">语句，过程返回，异常。原有的指针可能赋给另一个指针，你对这个指针也要做相同的事。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　相比之下，对于一段用资源管理技术实现的代码。你也用</span><span style="font-family:Verdana">grep</span><span style="font-family:宋体">检查所有的</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">，但是这次你只需要检查邻近的调用：</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　●</span><span style="font-family:Verdana">?</span><span style="font-family:宋体">这是一个直接的</span><span style="font-family:Verdana">Strong Pointer</span><span style="font-family:宋体">转换，还是我们在一个构造函数的函数体中？</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　●</span><span style="font-family:Verdana">?</span><span style="font-family:宋体">调用的返回知是否立即保存到对象中，构造函数中是否有可以产生异常的代码。？</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　●</span><span style="font-family:Verdana">?</span><span style="font-family:宋体">如果这样的话析构函数中时候有</span><span style="font-family:Verdana">delete?
</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　下一步，你需要用</span><span style="font-family:Verdana">grep</span><span style="font-family:宋体">查找所有的</span><span style="font-family:Verdana">release</span><span style="font-family:宋体">方法，并实施相同的检查。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　不同点是需要检查、理解单个执行路径和只需要做一些本地的检验。这难道不是提醒你非结构化的和结构化的程序设计的不同吗？原理上，你可以认为你可以应付</span><span style="font-family:Verdana">goto</span><span style="font-family:宋体">，并且跟踪所有的可能分支。另一方面，你可以将你的怀疑本地化为一段代码。本地化在两种情况下都是关键所在。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　在资源管理中的错误模式也比较容易调试。最常见的</span><span style="font-family:Verdana">bug</span><span style="font-family:宋体">是试图访问一个释放过的</span><span style="font-family:Verdana">strong pointer</span><span style="font-family:宋体">。这将导致一个错误，并且很容易跟踪。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><strong><span style="font-family:Verdana">1.2.9?</span><span style="font-family:宋体">共享的所有权</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　为每一个程序中的资源都找出或者指定一个所有者是一件很容易的事情吗？答案是出乎意料的，是！如果你发现了一些问题，这可能说明你的设计上存在问题。还有另一种情况就是共享所有权是最好的甚至是唯一的选择。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　共享的责任分配给被共享的对象和它的客户（</span><span style="font-family:Verdana">client</span><span style="font-family:宋体">）。一个共享资源必须为它的所有者保持一个引用计数。另一方面，所有者再释放资源的时候必须通报共享对象。最后一个释放资源的需要在最后负责</span><span style="font-family:Verdana">free</span><span style="font-family:宋体">的工作。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　最简单的共享的实现是共享对象继承引用计数的类</span><span style="font-family:Verdana">RefCounted</span><span style="font-family:宋体">：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">class RefCounted
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">public:
</span></p><p><span style="font-family:Verdana; font-size:8pt">RefCounted () : _count (1) {}
</span></p><p><span style="font-family:Verdana; font-size:8pt">int GetRefCount () const { return _count; }
</span></p><p><span style="font-family:Verdana; font-size:8pt">void IncRefCount () { _count++; }
</span></p><p><span style="font-family:Verdana; font-size:8pt">int DecRefCount () { return --_count; }
</span></p><p><span style="font-family:Verdana; font-size:8pt">private
</span></p><p><span style="font-family:Verdana; font-size:8pt">int _count;
</span></p><p><span style="font-family:Verdana; font-size:8pt">};</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　按照资源管理，一个引用计数是一种资源。如果你遵守它，你需要释放它。当你意识到这一事实的时候，剩下的就变得简单了。简单的遵循规则</span><span style="font-family:Verdana">--</span><span style="font-family:宋体">再构造函数中获得引用计数，在析构函数中释放。甚至有一个</span><span style="font-family:Verdana">RefCounted</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">smart pointer</span><span style="font-family:宋体">等价物：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">template &lt;class T&gt;
</span></p><p><span style="font-family:Verdana; font-size:8pt">class RefPtr
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">public:
</span></p><p><span style="font-family:Verdana; font-size:8pt">RefPtr (T * p) : _p (p) {}
</span></p><p><span style="font-family:Verdana; font-size:8pt">RefPtr (RefPtr&lt;T&gt; &amp; p)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">_p = p._p;
</span></p><p><span style="font-family:Verdana; font-size:8pt">_p-&gt;IncRefCount ();
</span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">~RefPtr ()
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">if (_p-&gt;DecRefCount () == 0)
</span></p><p><span style="font-family:Verdana; font-size:8pt">delete _p;
</span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">private
</span></p><p><span style="font-family:Verdana; font-size:8pt">T * _p;
</span></p><p><span style="font-family:Verdana; font-size:8pt">};</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　注意模板中的</span><span style="font-family:Verdana">T</span><span style="font-family:宋体">不比成为</span><span style="font-family:Verdana">RefCounted</span><span style="font-family:宋体">的后代，但是它必须有</span><span style="font-family:Verdana">IncRefCount</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">DecRefCount</span><span style="font-family:宋体">的方法。当然，一个便于使用的</span><span style="font-family:Verdana">RefPtr</span><span style="font-family:宋体">需要有一个重载的指针访问操作符。在</span><span style="font-family:Verdana">RefPtr</span><span style="font-family:宋体">中加入转换语义学（</span><span style="font-family:Verdana">transfer semantics</span><span style="font-family:宋体">）是读者的工作。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><strong><span style="font-family:Verdana">1.2.10?</span><span style="font-family:宋体">所有权网络</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　链表是资源管理分析中的一个很有意思的例子。如果你选择表成为链</span><span style="font-family:Verdana">(link)</span><span style="font-family:宋体">的所有者的话，你会陷入实现递归的所有权。每一个</span><span style="font-family:Verdana">link</span><span style="font-family:宋体">都是它的继承者的所有者，并且，相应的，余下的链表的所有者。下面是用</span><span style="font-family:Verdana">smart pointer</span><span style="font-family:宋体">实现的一个表单元：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">class Link
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">// ...
</span></p><p><span style="font-family:Verdana; font-size:8pt">private
</span></p><p><span style="font-family:Verdana; font-size:8pt">auto_ptr&lt;Link&gt; _next;
</span></p><p><span style="font-family:Verdana; font-size:8pt">};
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　最好的方法是，将连接控制封装到一个弄构进行资源转换的类中。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　对于双链表呢？安全的做法是指明一个方向，如</span><span style="font-family:Verdana">forward:
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">class DoubleLink
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">// ...
</span></p><p><span style="font-family:Verdana; font-size:8pt">private
</span></p><p><span style="font-family:Verdana; font-size:8pt">DoubleLink *_prev;
</span></p><p><span style="font-family:Verdana; font-size:8pt">auto_ptr&lt;DoubleLink&gt; _next;
</span></p><p><span style="font-family:Verdana; font-size:8pt">};</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　注意不要创建环形链表。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　这给我们带来了另外一个有趣的问题</span><span style="font-family:Verdana">--</span><span style="font-family:宋体">资源管理可以处理环形的所有权吗？它可以，用一个</span><span style="font-family:Verdana">mark-and-sweep</span><span style="font-family:宋体">的算法。这里是实现这种方法的一个例子：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">template&lt;class T&gt;
</span></p><p><span style="font-family:Verdana; font-size:8pt">class CyclPtr
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">public:
</span></p><p><span style="font-family:Verdana; font-size:8pt">CyclPtr (T * p)
</span></p><p><span style="font-family:Verdana; font-size:8pt">:_p (p), _isBeingDeleted (false)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{}
</span></p><p><span style="font-family:Verdana; font-size:8pt">~CyclPtr ()
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">_isBeingDeleted = true;
</span></p><p><span style="font-family:Verdana; font-size:8pt">if (!_p-&gt;IsBeingDeleted ())
</span></p><p><span style="font-family:Verdana; font-size:8pt">delete _p;
</span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">void Set (T * p)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">_p = p;
</span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">bool IsBeingDeleted () const { return _isBeingDeleted; }
</span></p><p><span style="font-family:Verdana; font-size:8pt">private
</span></p><p><span style="font-family:Verdana; font-size:8pt">T * _p;
</span></p><p><span style="font-family:Verdana; font-size:8pt">bool _isBeingDeleted;
</span></p><p><span style="font-family:Verdana; font-size:8pt">};</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　注意我们需要用</span><span style="font-family:Verdana">class T</span><span style="font-family:宋体">来实现方法</span><span style="font-family:Verdana">IsBeingDeleted</span><span style="font-family:宋体">，就像从</span><span style="font-family:Verdana">CyclPtr</span><span style="font-family:宋体">继承。对特殊的所有权网络普通化是十分直接的。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　将原有代码转换为资源管理代码</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">如果你是一个经验丰富的程序员，你一定会知道找资源的</span><span style="font-family:Verdana">bug</span><span style="font-family:宋体">是一件浪费时间的痛苦的经历。我不必说服你和你的团队花费一点时间来熟悉资源管理是十分值得的。你可以立即开始用这个方法，无论你是在开始一个新项目或者是在一个项目的中期。转换不必立即全部完成。下面是步骤。</span><span style="font-family:Verdana">
			</span></span></p><p style="margin-left: 57pt"><span style="color:#4b4b4b"><span style="font-size:8pt"><span style="font-family:宋体">（</span><span style="font-family:Verdana">1</span><span style="font-family:宋体">）</span></span><span style="font-family:Times New Roman; font-size:7pt">???????</span><span style="font-size:8pt"><span style="font-family:宋体">首先，在你的工程中建立基本的</span><span style="font-family:Verdana">Strong Pointer</span><span style="font-family:宋体">。然后通过查找代码中的</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">来开始封装裸指针。</span><span style="font-family:Verdana">
				</span></span></span></p><p style="margin-left: 57pt"><span style="color:#4b4b4b"><span style="font-size:8pt"><span style="font-family:宋体">（</span><span style="font-family:Verdana">2</span><span style="font-family:宋体">）</span></span><span style="font-family:Times New Roman; font-size:7pt">???????</span><span style="font-size:8pt"><span style="font-family:宋体">最先封装的是在过程中定义的临时指针。简单的将它们替换为</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">并且删除相应的</span><span style="font-family:Verdana">delete</span><span style="font-family:宋体">。如果一个指针在过程中没有被删除而是被返回，用</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">替换并在返回前调用</span><span style="font-family:Verdana">release</span><span style="font-family:宋体">方法。在你做第二次传递的时候，你需要处理对</span><span style="font-family:Verdana">release</span><span style="font-family:宋体">的调用。注意，即使是在这点，你的代码也可能更加</span><span style="font-family:Verdana">"</span><span style="font-family:宋体">精力充沛</span><span style="font-family:Verdana">"--</span><span style="font-family:宋体">你会移出代码中潜在的资源泄漏问题。</span><span style="font-family:Verdana">
				</span></span></span></p><p style="margin-left: 57pt"><span style="color:#4b4b4b"><span style="font-size:8pt"><span style="font-family:宋体">（</span><span style="font-family:Verdana">3</span><span style="font-family:宋体">）</span></span><span style="font-family:Times New Roman; font-size:7pt">???????</span><span style="font-size:8pt"><span style="font-family:宋体">下面是指向资源的裸指针。确保它们被独立的封装到</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">中，或者在构造函数中分配在析构函数中释放。如果你有传递所有权的行为的话，需要调用</span><span style="font-family:Verdana">release</span><span style="font-family:宋体">方法。如果你有容器所有对象，用</span><span style="font-family:Verdana">Strong Pointers</span><span style="font-family:宋体">重新实现它们。</span><span style="font-family:Verdana">
				</span></span></span></p><p style="margin-left: 57pt"><span style="color:#4b4b4b"><span style="font-size:8pt"><span style="font-family:宋体">（</span><span style="font-family:Verdana">4</span><span style="font-family:宋体">）</span></span><span style="font-family:Times New Roman; font-size:7pt">???????</span><span style="font-size:8pt"><span style="font-family:宋体">接下来，找到所有对</span><span style="font-family:Verdana">release</span><span style="font-family:宋体">的方法调用并且尽力清除所有，如果一个</span><span style="font-family:Verdana">release</span><span style="font-family:宋体">调用返回一个指针，将它修改传值返回一个</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">。</span><span style="font-family:Verdana">
				</span></span></span></p><p style="margin-left: 57pt"><span style="color:#4b4b4b"><span style="font-size:8pt"><span style="font-family:宋体">（</span><span style="font-family:Verdana">5</span><span style="font-family:宋体">）</span></span><span style="font-family:Times New Roman; font-size:7pt">???????</span><span style="font-size:8pt"><span style="font-family:宋体">重复着一过程，直到最后所有</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">release</span><span style="font-family:宋体">的调用都在构造函数或者资源转换的时候发生。这样，你在你的代码中处理了资源泄漏的问题。对其他资源进行相似的操作。</span><span style="font-family:Verdana">
				</span></span></span></p><p style="margin-left: 57pt"><span style="color:#4b4b4b"><span style="font-size:8pt"><span style="font-family:宋体">（</span><span style="font-family:Verdana">6</span><span style="font-family:宋体">）</span></span><span style="font-family:Times New Roman; font-size:7pt">???????</span><span style="font-size:8pt"><span style="font-family:宋体">你会发现资源管理清除了许多错误和异常处理带来的复杂性。不仅仅你的代码会变得精力充沛，它也会变得简单并容易维护。</span><span style="font-family:Verdana">
				</span></span></span></p><p><span style="color:#666666; font-size:22pt"><strong><span style="font-family:Verdana">2?</span><span style="font-family:宋体">内存泄漏</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:18pt"><strong><span style="font-family:Verdana">2.1 C++</span><span style="font-family:黑体">中动态内存分配引发问题的解决方案</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">假设我们要开发一个</span><span style="font-family:Verdana">String</span><span style="font-family:宋体">类，它可以方便地处理字符串数据。我们可以在类中声明一个数组，考虑到有时候字符串极长，我们可以把数组大小设为</span><span style="font-family:Verdana">200</span><span style="font-family:宋体">，但一般的情况下又不需要这么多的空间，这样是浪费了内存。对了，我们可以使用</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">操作符，这样是十分灵活的，但在类中就会出现许多意想不到的问题，本文就是针对这一现象而写的。现在，我们先来开发一个</span><span style="font-family:Verdana">String</span><span style="font-family:宋体">类，但它是一个不完善的类。的确，我们要刻意地使它出现各种各样的问题，这样才好对症下药。好了，我们开始吧！</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">/* String.h */
</span></p><p><span style="font-family:Verdana; font-size:8pt">#ifndef STRING_H_
</span></p><p><span style="font-family:Verdana; font-size:8pt">#define STRING_H_
</span></p><p><span style="font-family:Verdana; font-size:8pt">class String
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">private:
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">char * str; //</span><span style="font-family:宋体">存储数据</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">int len; //</span><span style="font-family:宋体">字符串长度</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">public:
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">String(const char * s); //</span><span style="font-family:宋体">构造函数</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">String(); //?</span><span style="font-family:宋体">默认构造函数</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">~String(); //?</span><span style="font-family:宋体">析构函数</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">friend ostream &amp; operator</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">(ostream &amp; os,const String&amp; st);
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">};
</span></p><p><span style="font-family:Verdana; font-size:8pt">#endif
</span></p><p><span style="font-family:Verdana; font-size:8pt">/*String.cpp*/
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">#include?</span><span style="font-family:宋体">＜</span><span style="font-family:Verdana">iostream</span><span style="font-family:宋体">＞</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">#include?</span><span style="font-family:宋体">＜</span><span style="font-family:Verdana">cstring</span><span style="font-family:宋体">＞</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">#include "String.h"
</span></p><p><span style="font-family:Verdana; font-size:8pt">using namespace std;
</span></p><p><span style="font-family:Verdana; font-size:8pt">String::String(const char * s)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">len = strlen(s);
</span></p><p><span style="font-family:Verdana; font-size:8pt">str = new char[len + 1];
</span></p><p><span style="font-family:Verdana; font-size:8pt">strcpy(str, s);
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">}//</span><span style="font-family:宋体">拷贝数据</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">String::String()
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">len =0;
</span></p><p><span style="font-family:Verdana; font-size:8pt">str = new char[len+1];
</span></p><p><span style="font-family:Verdana; font-size:8pt">str[0]='"0';
</span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">String::~String()
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">cout</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">"</span><span style="font-family:宋体">这个字符串将被删除：</span><span style="font-family:Verdana">"</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">str</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">'"n';//</span><span style="font-family:宋体">为了方便观察结果，特留此行代码。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">delete [] str;
</span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">ostream &amp; operator</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">(ostream &amp; os, const String &amp; st)
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">os?</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">?st.str;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">return os;
</span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">/*test_right.cpp*/
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">#include?</span><span style="font-family:宋体">＜</span><span style="font-family:Verdana">iostream</span><span style="font-family:宋体">＞</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">#include?</span><span style="font-family:宋体">＜</span><span style="font-family:Verdana">stdlib.h</span><span style="font-family:宋体">＞</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">#include "String.h"
</span></p><p><span style="font-family:Verdana; font-size:8pt">using namespace std;
</span></p><p><span style="font-family:Verdana; font-size:8pt">int main()
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">String temp("</span><span style="font-family:宋体">天极网</span><span style="font-family:Verdana">");
</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">cout</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">temp</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">'"n';
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">system("PAUSE");
</span></p><p><span style="font-family:Verdana; font-size:8pt">return 0;
</span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p>　　
?</p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　运行结果：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-size:8pt"><span style="font-family:宋体">　　天极网</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　请按任意键继续</span><span style="font-family:Verdana">. . .</span></span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　大家可以看到，以上程序十分正确，而且也是十分有用的。可是，我们不能被表面现象所迷惑！下面，请大家用</span><span style="font-family:Verdana">test_String.cpp</span><span style="font-family:宋体">文件替换</span><span style="font-family:Verdana">test_right.cpp</span><span style="font-family:宋体">文件进行编译，看看结果。有的编译器可能就是根本不能进行编译！</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-family:Verdana; font-size:8pt">test_String.cpp:
</span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-size:8pt"><span style="font-family:Verdana">#include?</span><span style="font-family:宋体">＜</span><span style="font-family:Verdana">iostream</span><span style="font-family:宋体">＞</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">#include?</span><span style="font-family:宋体">＜</span><span style="font-family:Verdana">stdlib.h</span><span style="font-family:宋体">＞</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">#include "String.h"
</span></p><p><span style="font-family:Verdana; font-size:8pt">using namespace std;
</span></p><p><span style="font-family:Verdana; font-size:8pt">void show_right(const String&amp;);
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">void show_String(const String);//</span><span style="font-family:宋体">注意，参数非引用，而是按值传递。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">int main()
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">String test1("</span><span style="font-family:宋体">第一个范例。</span><span style="font-family:Verdana">");
</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">String test2("</span><span style="font-family:宋体">第二个范例。</span><span style="font-family:Verdana">");
</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">String test3("</span><span style="font-family:宋体">第三个范例。</span><span style="font-family:Verdana">");
</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">String test4("</span><span style="font-family:宋体">第四个范例。</span><span style="font-family:Verdana">");
</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">cout</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">"</span><span style="font-family:宋体">下面分别输入三个范例：</span><span style="font-family:Verdana">"n";
</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">cout</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">test1</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">endl;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">cout</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">test2</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">endl;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">cout</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">test3</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">endl;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">String* String1=new String(test1);
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">cout</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">*String1</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">endl;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">delete String1;
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">cout</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">test1</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">endl; //</span><span style="font-family:宋体">在</span><span style="font-family:Verdana">Dev-cpp</span><span style="font-family:宋体">上没有任何反应。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">cout</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">"</span><span style="font-family:宋体">使用正确的函数：</span><span style="font-family:Verdana">"</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">endl;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">show_right(test2);
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">cout</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">test2</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">endl;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">cout</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">"</span><span style="font-family:宋体">使用错误的函数：</span><span style="font-family:Verdana">"</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">endl;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">show_String(test2);
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">cout</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">test2</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">endl; //</span><span style="font-family:宋体">这一段代码出现严重的错误！</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">String String2(test3);
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">cout</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">"String2: "</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">String2</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">endl;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">String String3;
</span></p><p><span style="font-family:Verdana; font-size:8pt">String3=test4;
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">cout</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">"String3: "</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">String3</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">endl;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">cout</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">"</span><span style="font-family:宋体">下面，程序结束，析构函数将被调用。</span><span style="font-family:Verdana">"</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">endl;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">return 0;
</span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">void show_right(const String&amp; a)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">cout</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">a</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">endl;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">void show_String(const String a)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">cout</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">a</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">endl;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　运行结果：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-size:8pt"><span style="font-family:宋体">　　下面分别输入三个范例：</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　第一个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　第二个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　第三个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　第一个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　这个字符串将被删除：第一个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　使用正确的函数：</span><span style="font-family:Verdana">
								</span></span></p><p>　　
?</p><p><span style="font-size:8pt"><span style="font-family:宋体">　　第二个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　第二个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　使用错误的函数：</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　第二个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　这个字符串将被删除：第二个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　这个字符串将被删除：</span><span style="font-family:Verdana">?=
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">?=
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">String2:?</span><span style="font-family:宋体">第三个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">String3:?</span><span style="font-family:宋体">第四个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　下面，程序结束，析构函数将被调用。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　这个字符串将被删除：第四个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　这个字符串将被删除：第三个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　这个字符串将被删除：</span><span style="font-family:Verdana">?=
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　这个字符串将被删除：</span><span style="font-family:Verdana">x =
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　这个字符串将被删除：</span><span style="font-family:Verdana">?=
</span></span></p><p><span style="font-family:宋体; font-size:8pt">　　这个字符串将被删除：</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">现在，请大家自己试试运行结果，或许会更加惨不忍睹呢！下面，我为大家一一分析原因。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">首先，大家要知道，</span><span style="font-family:Verdana">C</span><span style="font-family:宋体">＋＋类有以下这些极为重要的函数：</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">一：复制构造函数。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">二：赋值函数。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">我们先来讲复制构造函数。什么是复制构造函数呢？比如，我们可以写下这样的代码：</span><span style="font-family:Verdana">String test1(test2);</span><span style="font-family:宋体">这是进行初始化。我们知道，初始化对象要用构造函数。可这儿呢？按理说，应该有声明为这样的构造函数：</span><span style="font-family:Verdana">String(const String &amp;);</span><span style="font-family:宋体">可是，我们并没有定义这个构造函数呀？答案是，</span><span style="font-family:Verdana">C</span><span style="font-family:宋体">＋＋提供了默认的复制构造函数，问题也就出在这儿。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">（</span><span style="font-family:Verdana">1</span><span style="font-family:宋体">）：什么时候会调用复制构造函数呢？（以</span><span style="font-family:Verdana">String</span><span style="font-family:宋体">类为例。）</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　在我们提供这样的代码：</span><span style="font-family:Verdana">String test1(test2)</span><span style="font-family:宋体">时，它会被调用；当函数的参数列表为按值传递，也就是没有用引用和指针作为类型时，如：</span><span style="font-family:Verdana">void show_String(const String)</span><span style="font-family:宋体">，它会被调用。其实，还有一些情况，但在这儿就不列举了。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">（</span><span style="font-family:Verdana">2</span><span style="font-family:宋体">）：它是什么样的函数。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">它的作用就是把两个类进行复制。拿</span><span style="font-family:Verdana">String</span><span style="font-family:宋体">类为例，</span><span style="font-family:Verdana">C</span><span style="font-family:宋体">＋＋提供的默认复制构造函数是这样的：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">String(const String&amp; a)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">str=a.str;
</span></p><p><span style="font-family:Verdana; font-size:8pt">len=a.len;
</span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">在平时，这样并不会有任何的问题出现，但我们用了</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">操作符，涉及到了动态内存分配，我们就不得不谈谈浅复制和深复制了。以上的函数就是实行的浅复制，它只是复制了指针，而并没有复制指针指向的数据，可谓一点儿用也没有。打个比方吧！就像一个朋友让你把一个程序通过网络发给他，而你大大咧咧地把快捷方式发给了他，有什么用处呢？我们来具体谈谈：</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">假如，</span><span style="font-family:Verdana">A</span><span style="font-family:宋体">对象中存储了这样的字符串："</span><span style="font-family:Verdana">C</span><span style="font-family:宋体">＋＋"。它的地址为</span><span style="font-family:Verdana">2000</span><span style="font-family:宋体">。现在，我们把</span><span style="font-family:Verdana">A</span><span style="font-family:宋体">对象赋给</span><span style="font-family:Verdana">B</span><span style="font-family:宋体">对象：</span><span style="font-family:Verdana">String B=A</span><span style="font-family:宋体">。现在，</span><span style="font-family:Verdana">A</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">B</span><span style="font-family:宋体">对象的</span><span style="font-family:Verdana">str</span><span style="font-family:宋体">指针均指向</span><span style="font-family:Verdana">2000</span><span style="font-family:宋体">地址。看似可以使用，但如果</span><span style="font-family:Verdana">B</span><span style="font-family:宋体">对象的析构函数被调用时，则地址</span><span style="font-family:Verdana">2000</span><span style="font-family:宋体">处的字符串"</span><span style="font-family:Verdana">C</span><span style="font-family:宋体">＋＋"已经被从内存中抹去，而</span><span style="font-family:Verdana">A</span><span style="font-family:宋体">对象仍然指向地址</span><span style="font-family:Verdana">2000</span><span style="font-family:宋体">。这时，如果我们写下这样的代码：</span><span style="font-family:Verdana">cout</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">A</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">endl;</span><span style="font-family:宋体">或是等待程序结束，</span><span style="font-family:Verdana">A</span><span style="font-family:宋体">对象的析构函数被调用时，</span><span style="font-family:Verdana">A</span><span style="font-family:宋体">对象的数据能否显示出来呢？只会是乱码。而且，程序还会这样做：连续对地址</span><span style="font-family:Verdana">2000</span><span style="font-family:宋体">处使用两次</span><span style="font-family:Verdana">delete</span><span style="font-family:宋体">操作符，这样的后果是十分严重的！</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">本例中，有这样的代码：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">String* String1=new String(test1);
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">cout</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">*String1</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">endl;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">delete String1;</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　假设</span><span style="font-family:Verdana">test1</span><span style="font-family:宋体">中</span><span style="font-family:Verdana">str</span><span style="font-family:宋体">指向的地址为</span><span style="font-family:Verdana">2000,</span><span style="font-family:宋体">而</span><span style="font-family:Verdana">String</span><span style="font-family:宋体">中</span><span style="font-family:Verdana">str</span><span style="font-family:宋体">指针同样指向地址</span><span style="font-family:Verdana">2000</span><span style="font-family:宋体">，我们删除了</span><span style="font-family:Verdana">2000</span><span style="font-family:宋体">处的数据，而</span><span style="font-family:Verdana">test1</span><span style="font-family:宋体">对象呢？已经被破坏了。大家从运行结果上可以看到，我们使用</span><span style="font-family:Verdana">cout</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">test1</span><span style="font-family:宋体">时，一点反应也没有。而在</span><span style="font-family:Verdana">test1</span><span style="font-family:宋体">的析构函数被调用时，显示是这样："这个字符串将被删除："。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">再看看这段代码：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-size:8pt"><span style="font-family:Verdana">cout</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">"</span><span style="font-family:宋体">使用错误的函数：</span><span style="font-family:Verdana">"</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">endl;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">show_String(test2);
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">cout</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">test2</span><span style="font-family:宋体">＜＜</span><span style="font-family:Verdana">endl;//</span><span style="font-family:宋体">这一段代码出现严重的错误！</span></span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:Verdana">show_String</span><span style="font-family:宋体">函数的参数列表</span><span style="font-family:Verdana">void show_String(const String a)</span><span style="font-family:宋体">是按值传递的，所以，我们相当于执行了这样的代码：</span><span style="font-family:Verdana">String a=test2;</span><span style="font-family:宋体">函数执行完毕，由于生存周期的缘故，对象</span><span style="font-family:Verdana">a</span><span style="font-family:宋体">被析构函数删除，我们马上就可以看到错误的显示结果了：这个字符串将被删除：</span><span style="font-family:Verdana">?=</span><span style="font-family:宋体">。当然，</span><span style="font-family:Verdana">test2</span><span style="font-family:宋体">也被破坏了。解决的办法很简单，当然是手工定义一个复制构造函数喽！人力可以胜天！</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">String::String(const String&amp; a)<br/>{<br/>len=a.len;<br/>str=new char(len+1);<br/>strcpy(str,a.str);<br/>}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　我们执行的是深复制。这个函数的功能是这样的：假设对象</span><span style="font-family:Verdana">A</span><span style="font-family:宋体">中的</span><span style="font-family:Verdana">str</span><span style="font-family:宋体">指针指向地址</span><span style="font-family:Verdana">2000</span><span style="font-family:宋体">，内容为"</span><span style="font-family:Verdana">I am a C++ Boy!</span><span style="font-family:宋体">"。我们执行代码</span><span style="font-family:Verdana">String B=A</span><span style="font-family:宋体">时，我们先开辟出一块内存，假设为</span><span style="font-family:Verdana">3000</span><span style="font-family:宋体">。我们用</span><span style="font-family:Verdana">strcpy</span><span style="font-family:宋体">函数将地址</span><span style="font-family:Verdana">2000</span><span style="font-family:宋体">的内容拷贝到地址</span><span style="font-family:Verdana">3000</span><span style="font-family:宋体">中，再将对象</span><span style="font-family:Verdana">B</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">str</span><span style="font-family:宋体">指针指向地址</span><span style="font-family:Verdana">3000</span><span style="font-family:宋体">。这样，就互不干扰了。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">大家把这个函数加入程序中，问题就解决了大半，但还没有完全解决，问题在赋值函数上。我们的程序中有这样的段代码：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">String String3;
</span></p><p><span style="font-family:Verdana; font-size:8pt">String3=test4;</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　经过我前面的讲解，大家应该也会对这段代码进行寻根摸底：凭什么可以这样做：</span><span style="font-family:Verdana">String3=test4</span><span style="font-family:宋体">？？？原因是，</span><span style="font-family:Verdana">C</span><span style="font-family:宋体">＋＋为了用户的方便，提供的这样的一个操作符重载函数：</span><span style="font-family:Verdana">operator=</span><span style="font-family:宋体">。所以，我们可以这样做。大家应该猜得到，它同样是执行了浅复制，出了同样的毛病。比如，执行了这段代码后，析构函数开始大展神威</span><span style="font-family:Verdana">^_^</span><span style="font-family:宋体">。由于这些变量是后进先出的，所以最后的</span><span style="font-family:Verdana">String3</span><span style="font-family:宋体">变量先被删除：这个字符串将被删除：第四个范例。很正常。最后，删除到</span><span style="font-family:Verdana">test4</span><span style="font-family:宋体">的时候，问题来了：这个字符串将被删除：</span><span style="font-family:Verdana">?=</span><span style="font-family:宋体">。原因我不用赘述了，只是这个赋值函数怎么写，还有一点儿学问呢！大家请看：</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">平时，我们可以写这样的代码：</span><span style="font-family:Verdana">x=y=z</span><span style="font-family:宋体">。（均为整型变量。）而在类对象中，我们同样要这样，因为这很方便。而对象</span><span style="font-family:Verdana">A=B=C</span><span style="font-family:宋体">就是</span><span style="font-family:Verdana">A.operator=(B.operator=(c))</span><span style="font-family:宋体">。而这个</span><span style="font-family:Verdana">operator=</span><span style="font-family:宋体">函数的参数列表应该是：</span><span style="font-family:Verdana">const String&amp; a</span><span style="font-family:宋体">，所以，大家不难推出，要实现这样的功能，返回值也要是</span><span style="font-family:Verdana">String&amp;</span><span style="font-family:宋体">，这样才能实现</span><span style="font-family:Verdana">A</span><span style="font-family:宋体">＝</span><span style="font-family:Verdana">B</span><span style="font-family:宋体">＝</span><span style="font-family:Verdana">C</span><span style="font-family:宋体">。我们先来写写看：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">String&amp; String::operator=(const String&amp; a)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">delete [] str;//</span><span style="font-family:宋体">先删除自身的数据</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">len=a.len;
</span></p><p><span style="font-family:Verdana; font-size:8pt">str=new char[len+1];
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">strcpy(str,a.str);//</span><span style="font-family:宋体">此三行为进行拷贝</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">return *this;//</span><span style="font-family:宋体">返回自身的引用</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">是不是这样就行了呢？我们假如写出了这种代码：</span><span style="font-family:Verdana">A=A</span><span style="font-family:宋体">，那么大家看看，岂不是把</span><span style="font-family:Verdana">A</span><span style="font-family:宋体">对象的数据给删除了吗？这样可谓引发一系列的错误。所以，我们还要检查是否为自身赋值。只比较两对象的数据是不行了，因为两个对象的数据很有可能相同。我们应该比较地址。以下是完好的赋值函数：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">String&amp; String::operator=(const String&amp; a)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-family:Verdana; font-size:8pt">if(this==&amp;a)
</span></p><p><span style="font-family:Verdana; font-size:8pt">return *this;
</span></p><p><span style="font-family:Verdana; font-size:8pt">delete [] str;
</span></p><p><span style="font-family:Verdana; font-size:8pt">len=a.len;
</span></p><p><span style="font-family:Verdana; font-size:8pt">str=new char[len+1];
</span></p><p><span style="font-family:Verdana; font-size:8pt">strcpy(str,a.str);
</span></p><p><span style="font-family:Verdana; font-size:8pt">return *this;
</span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">把这些代码加入程序，问题就完全解决，下面是运行结果：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-size:8pt"><span style="font-family:宋体">　　下面分别输入三个范例：</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　第一个范例</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　第二个范例</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　第三个范例</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　第一个范例</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　这个字符串将被删除：第一个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　第一个范例</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　使用正确的函数：</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　第二个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　第二个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　使用错误的函数：</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　第二个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　这个字符串将被删除：第二个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　第二个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">String2:?</span><span style="font-family:宋体">第三个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">String3:?</span><span style="font-family:宋体">第四个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　下面，程序结束，析构函数将被调用。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　这个字符串将被删除：第四个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　这个字符串将被删除：第三个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　这个字符串将被删除：第四个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　这个字符串将被删除：第三个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　这个字符串将被删除：第二个范例。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:宋体; font-size:8pt">　　这个字符串将被删除：第一个范例。</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:18pt"><strong><span style="font-family:Verdana">2.2?</span><span style="font-family:黑体">如何对付内存泄漏？</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">写出那些不会导致任何内存泄漏的代码。很明显，当你的代码中到处充满了</span><span style="font-family:Verdana">new?</span><span style="font-family:宋体">操作、</span><span style="font-family:Verdana">delete</span><span style="font-family:宋体">操作和指针运算的话，你将会在某个地方搞晕了头，导致内存泄漏，指针引用错误，以及诸如此类的问题。这和你如何小心地对待内存分配工作其实完全没有关系：代码的复杂性最终总是会超过你能够付出的时间和努力。于是随后产生了一些成功的技巧，它们依赖于将内存分配（</span><span style="font-family:Verdana">allocations</span><span style="font-family:宋体">）与重新分配（</span><span style="font-family:Verdana">deallocation</span><span style="font-family:宋体">）工作隐藏在易于管理的类型之后。标准容器（</span><span style="font-family:Verdana">standard containers</span><span style="font-family:宋体">）是一个优秀的例子。它们不是通过你而是自己为元素管理内存，从而避免了产生糟糕的结果。想象一下，没有</span><span style="font-family:Verdana">string</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">vector</span><span style="font-family:宋体">的帮助，写出这个：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr style="height: 483px"><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">#include&lt;vector&gt;
</span></p><p><span style="font-family:Verdana; font-size:8pt">#include&lt;string&gt;
</span></p><p><span style="font-family:Verdana; font-size:8pt">#include&lt;iostream&gt;
</span></p><p><span style="font-family:Verdana; font-size:8pt">#include&lt;algorithm&gt;
</span></p><p><span style="font-family:Verdana; font-size:8pt">using namespace std;
</span></p><p><span style="font-family:Verdana; font-size:8pt">int main() // small program messing around with strings
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">cout &lt;&lt; "enter some whitespace-separated words:"n";
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">vector&lt;string&gt; v;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">string s;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">while (cin&gt;&gt;s) v.push_back(s);
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">sort(v.begin(),v.end());
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">string cat;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">typedef vector&lt;string&gt;::const_iterator Iter;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">for (Iter p = v.begin(); p!=v.end(); ++p) cat += *p+"+";
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">cout &lt;&lt; cat &lt;&lt;?</span><span style="font-family:宋体">'</span><span style="font-family:Verdana">"n</span><span style="font-family:宋体">'</span><span style="font-family:Verdana">;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　你有多少机会在第一次就得到正确的结果？你又怎么知道你没有导致内存泄漏呢？</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　注意，没有出现显式的内存管理，宏，造型，溢出检查，显式的长度限制，以及指针。通过使用函数对象和标准算法（</span><span style="font-family:Verdana">standard algorithm</span><span style="font-family:宋体">），我可以避免使用指针——例如使用迭代子（</span><span style="font-family:Verdana">iterator</span><span style="font-family:宋体">），不过对于一个这么小的程序来说有点小题大作了。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　这些技巧并不完美，要系统化地使用它们也并不总是那么容易。但是，应用它们产生了惊人的差异，而且通过减少显式的内存分配与重新分配的次数，你甚至可以使余下的例子更加容易被跟踪。早在</span><span style="font-family:Verdana">1981</span><span style="font-family:宋体">年，我就指出，通过将我必须显式地跟踪的对象的数量从几万个减少到几打，为了使程序正确运行而付出的努力从可怕的苦工，变成了应付一些可管理的对象，甚至更加简单了。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　如果你的程序还没有包含将显式内存管理减少到最小限度的库，那么要让你程序完成和正确运行的话，最快的途径也许就是先建立一个这样的库。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　模板和标准库实现了容器、资源句柄以及诸如此类的东西，更早的使用甚至在多年以前。异常的使用使之更加完善。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　如果你实在不能将内存分配</span><span style="font-family:Verdana">/</span><span style="font-family:宋体">重新分配的操作隐藏到你需要的对象中时，你可以使用资源句柄（</span><span style="font-family:Verdana">resource handle</span><span style="font-family:宋体">），以将内存泄漏的可能性降至最低。这里有个例子：我需要通过一个函数，在空闲内存中建立一个对象并返回它。这时候可能忘记释放这个对象。毕竟，我们不能说，仅仅关注当这个指针要被释放的时候，谁将负责去做。使用资源句柄，这里用了标准库中的</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">，使需要为之负责的地方变得明确了。</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">#include&lt;memory&gt;
</span></p><p><span style="font-family:Verdana; font-size:8pt">#include&lt;iostream&gt;
</span></p><p><span style="font-family:Verdana; font-size:8pt">using namespace std;
</span></p><p><span style="font-family:Verdana; font-size:8pt">struct S {
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">S() { cout &lt;&lt; "make an S"n"; }
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">~S() { cout &lt;&lt; "destroy an S"n"; }
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">S(const S&amp;) { cout &lt;&lt; "copy initialize an S"n"; }
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">S&amp; operator=(const S&amp;) { cout &lt;&lt; "copy assign an S"n"; }
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">};
</span></p><p><span style="font-family:Verdana; font-size:8pt">S* f()
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">return new S; //?</span><span style="font-family:宋体">谁该负责释放这个</span><span style="font-family:Verdana">S</span><span style="font-family:宋体">？</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">};
</span></p><p><span style="font-family:Verdana; font-size:8pt">auto_ptr&lt;S&gt; g()
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">return auto_ptr&lt;S&gt;(new S); //?</span><span style="font-family:宋体">显式传递负责释放这个</span><span style="font-family:Verdana">S
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">int main()
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">cout &lt;&lt; "start main"n";
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">S* p = f();
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">cout &lt;&lt; "after f() before g()"n";
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">// S* q = g(); //?</span><span style="font-family:宋体">将被编译器捕捉</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">auto_ptr&lt;S&gt; q = g();
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">cout &lt;&lt; "exit main"n";
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">// *p</span><span style="font-family:宋体">产生了内存泄漏</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">// *q</span><span style="font-family:宋体">被自动释放</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　在更一般的意义上考虑资源，而不仅仅是内存。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">如果在你的环境中不能系统地应用这些技巧（例如，你必须使用别的地方的代码，或者你的程序的另一部分简直是原始人类（译注：原文是</span><span style="font-family:Verdana">Neanderthals</span><span style="font-family:宋体">，尼安德特人，旧石器时代广泛分布在欧洲的猿人）写的，如此等等），那么注意使用一个内存泄漏检测器作为开发过程的一部分，或者插入一个垃圾收集器（</span><span style="font-family:Verdana">garbage collector</span><span style="font-family:宋体">）。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:18pt"><strong><span style="font-family:Verdana">2.3</span><span style="font-family:黑体">浅谈</span><span style="font-family:Verdana">C/C++</span><span style="font-family:黑体">内存泄漏及其检测工具</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　对于一个</span><span style="font-family:Verdana">c/c++</span><span style="font-family:宋体">程序员来说，内存泄漏是一个常见的也是令人头疼的问题。已经有许多技术被研究出来以应对这个问题，比如</span><span style="font-family:Verdana">Smart Pointer</span><span style="font-family:宋体">，</span><span style="font-family:Verdana">Garbage Collection</span><span style="font-family:宋体">等。</span><span style="font-family:Verdana">Smart Pointer</span><span style="font-family:宋体">技术比较成熟，</span><span style="font-family:Verdana">STL</span><span style="font-family:宋体">中已经包含支持</span><span style="font-family:Verdana">Smart Pointer</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">class</span><span style="font-family:宋体">，但是它的使用似乎并不广泛，而且它也不能解决所有的问题；</span><span style="font-family:Verdana">Garbage Collection</span><span style="font-family:宋体">技术在</span><span style="font-family:Verdana">Java</span><span style="font-family:宋体">中已经比较成熟，但是在</span><span style="font-family:Verdana">c/c++</span><span style="font-family:宋体">领域的发展并不顺畅，虽然很早就有人思考在</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">中也加入</span><span style="font-family:Verdana">GC</span><span style="font-family:宋体">的支持。现实世界就是这样的，作为一个</span><span style="font-family:Verdana">c/c++</span><span style="font-family:宋体">程序员，内存泄漏是你心中永远的痛。不过好在现在有许多工具能够帮助我们验证内存泄漏的存在，找出发生问题的代码。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><strong><span style="font-family:Verdana">2.3.1?</span><span style="font-family:宋体">内存泄漏的定义</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">一般我们常说的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的（内存块的大小可以在程序运行期决定），使用完后必须显示释放的内存。应用程序一般使用</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">，</span><span style="font-family:Verdana">realloc</span><span style="font-family:宋体">，</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">等函数从堆中分配到一块内存，使用完后，程序必须负责相应的调用</span><span style="font-family:Verdana">free</span><span style="font-family:宋体">或</span><span style="font-family:Verdana">delete</span><span style="font-family:宋体">释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。以下这段小程序演示了堆内存发生泄漏的情形：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">void MyFunction(int nSize)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">char* p= new char[nSize];
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">if( !GetStringFrom( p, nSize ) ){
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">MessageBox(</span><span style="font-family:宋体">"</span><span style="font-family:Verdana">Error</span><span style="font-family:宋体">"</span><span style="font-family:Verdana">);
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">return;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">}
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　…</span><span style="font-family:Verdana">//using the string pointed by p;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">delete p;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　当函数</span><span style="font-family:Verdana">GetStringFrom()</span><span style="font-family:宋体">返回零的时候，指针</span><span style="font-family:Verdana">p</span><span style="font-family:宋体">指向的内存就不会被释放。这是一种常见的发生内存泄漏的情形。程序在入口处分配内存，在出口处释放内存，但是</span><span style="font-family:Verdana">c</span><span style="font-family:宋体">函数可以在任何地方退出，所以一旦有某个出口处没有释放应该释放的内存，就会发生内存泄漏。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　广义的说，内存泄漏不仅仅包含堆内存的泄漏，还包含系统资源的泄漏</span><span style="font-family:Verdana">(resource leak)</span><span style="font-family:宋体">，比如核心态</span><span style="font-family:Verdana">HANDLE</span><span style="font-family:宋体">，</span><span style="font-family:Verdana">GDI Object</span><span style="font-family:宋体">，</span><span style="font-family:Verdana">SOCKET</span><span style="font-family:宋体">，</span><span style="font-family:Verdana">?Interface</span><span style="font-family:宋体">等，从根本上说这些由操作系统分配的对象也消耗内存，如果这些对象发生泄漏最终也会导致内存的泄漏。而且，某些对象消耗的是核心态内存，这些对象严重泄漏时会导致整个操作系统不稳定。所以相比之下，系统资源的泄漏比堆内存的泄漏更为严重。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:Verdana">GDI Object</span><span style="font-family:宋体">的泄漏是一种常见的资源泄漏：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">void CMyView::OnPaint( CDC* pDC )
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">CBitmap bmp;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">CBitmap* pOldBmp;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">bmp.LoadBitmap(IDB_MYBMP);
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">pOldBmp = pDC-&gt;SelectObject( &amp;bmp );
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　…</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">if( Something() ){
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">return;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">}
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">pDC-&gt;SelectObject( pOldBmp );
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">return;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　当函数</span><span style="font-family:Verdana">Something()</span><span style="font-family:宋体">返回非零的时候，程序在退出前没有把</span><span style="font-family:Verdana">pOldBmp</span><span style="font-family:宋体">选回</span><span style="font-family:Verdana">pDC</span><span style="font-family:宋体">中，这会导致</span><span style="font-family:Verdana">pOldBmp</span><span style="font-family:宋体">指向的</span><span style="font-family:Verdana">HBITMAP</span><span style="font-family:宋体">对象发生泄漏。这个程序如果长时间的运行，可能会导致整个系统花屏。这种问题在</span><span style="font-family:Verdana">Win9x</span><span style="font-family:宋体">下比较容易暴露出来，因为</span><span style="font-family:Verdana">Win9x</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">GDI</span><span style="font-family:宋体">堆比</span><span style="font-family:Verdana">Win2k</span><span style="font-family:宋体">或</span><span style="font-family:Verdana">NT</span><span style="font-family:宋体">的要小很多。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><strong><span style="font-family:Verdana">2.3.2?</span><span style="font-family:宋体">内存泄漏的发生方式</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　以发生的方式来分类，内存泄漏可以分为</span><span style="font-family:Verdana">4</span><span style="font-family:宋体">类：</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">1.?</span><span style="font-family:宋体">常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。比如例二，如果</span><span style="font-family:Verdana">Something()</span><span style="font-family:宋体">函数一直返回</span><span style="font-family:Verdana">True</span><span style="font-family:宋体">，那么</span><span style="font-family:Verdana">pOldBmp</span><span style="font-family:宋体">指向的</span><span style="font-family:Verdana">HBITMAP</span><span style="font-family:宋体">对象总是发生泄漏。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">2.?</span><span style="font-family:宋体">偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。比如例二，如果</span><span style="font-family:Verdana">Something()</span><span style="font-family:宋体">函数只有在特定环境下才返回</span><span style="font-family:Verdana">True</span><span style="font-family:宋体">，那么</span><span style="font-family:Verdana">pOldBmp</span><span style="font-family:宋体">指向的</span><span style="font-family:Verdana">HBITMAP</span><span style="font-family:宋体">对象并不总是发生泄漏。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:Verdana">3.?</span><span style="font-family:宋体">一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，但是因为这个类是一个</span><span style="font-family:Verdana">Singleton</span><span style="font-family:宋体">，所以内存泄漏只会发生一次。另一个例子：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">char* g_lpszFileName = NULL;
</span></p><p><span style="font-family:Verdana; font-size:8pt">void SetFileName( const char* lpcszFileName )
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">if( g_lpszFileName ){
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">free( g_lpszFileName );
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">}
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">g_lpszFileName = strdup( lpcszFileName );
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　如果程序在结束的时候没有释放</span><span style="font-family:Verdana">g_lpszFileName</span><span style="font-family:宋体">指向的字符串，那么，即使多次调用</span><span style="font-family:Verdana">SetFileName()</span><span style="font-family:宋体">，总会有一块内存，而且仅有一块内存发生泄漏。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:Verdana">4.?</span><span style="font-family:宋体">隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。举一个例子：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">class Connection
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">public:
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">Connection( SOCKET s);
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">~Connection();
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　…</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">private:
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">SOCKET _socket;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　…</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">};
</span></p><p><span style="font-family:Verdana; font-size:8pt">class ConnectionManager
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">public:
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">ConnectionManager(){}
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">~ConnectionManager(){
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　</span><span style="font-family:Verdana">list::iterator it;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　</span><span style="font-family:Verdana">for( it = _connlist.begin(); it != _connlist.end(); ++it ){
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　　</span><span style="font-family:Verdana">delete?</span><span style="font-family:宋体">（</span><span style="font-family:Verdana">*it</span><span style="font-family:宋体">）</span><span style="font-family:Verdana">;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　</span><span style="font-family:Verdana">}
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　</span><span style="font-family:Verdana">_connlist.clear();
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">}
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">void OnClientConnected( SOCKET s ){
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　</span><span style="font-family:Verdana">Connection* p = new Connection(s);
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　</span><span style="font-family:Verdana">_connlist.push_back(p);
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">}
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">void OnClientDisconnected( Connection* pconn ){
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　</span><span style="font-family:Verdana">_connlist.remove( pconn );
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　</span><span style="font-family:Verdana">delete pconn;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">}
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">private:
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">list _connlist;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">};</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　假设在</span><span style="font-family:Verdana">Client</span><span style="font-family:宋体">从</span><span style="font-family:Verdana">Server</span><span style="font-family:宋体">端断开后，</span><span style="font-family:Verdana">Server</span><span style="font-family:宋体">并没有呼叫</span><span style="font-family:Verdana">OnClientDisconnected()</span><span style="font-family:宋体">函数，那么代表那次连接的</span><span style="font-family:Verdana">Connection</span><span style="font-family:宋体">对象就不会被及时的删除（在</span><span style="font-family:Verdana">Server</span><span style="font-family:宋体">程序退出的时候，所有</span><span style="font-family:Verdana">Connection</span><span style="font-family:宋体">对象会在</span><span style="font-family:Verdana">ConnectionManager</span><span style="font-family:宋体">的析构函数里被删除）。当不断的有连接建立、断开时隐式内存泄漏就发生了。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><strong><span style="font-family:Verdana">2.3.3?</span><span style="font-family:宋体">检测内存泄漏</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　检测内存泄漏的关键是要能截获住对分配内存和释放内存的函数的调用。截获住这两个函数，我们就能跟踪每一块内存的生命周期，比如，每当成功的分配一块内存后，就把它的指针加入一个全局的</span><span style="font-family:Verdana">list</span><span style="font-family:宋体">中；每当释放一块内存，再把它的指针从</span><span style="font-family:Verdana">list</span><span style="font-family:宋体">中删除。这样，当程序结束的时候，</span><span style="font-family:Verdana">list</span><span style="font-family:宋体">中剩余的指针就是指向那些没有被释放的内存。这里只是简单的描述了检测内存泄漏的基本原理，详细的算法可以参见</span><span style="font-family:Verdana">Steve Maguire</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">&lt;&lt;Writing Solid Code&gt;&gt;</span><span style="font-family:宋体">。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　如果要检测堆内存的泄漏，那么需要截获住</span><span style="font-family:Verdana">malloc/realloc/free</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">new/delete</span><span style="font-family:宋体">就可以了（其实</span><span style="font-family:Verdana">new/delete</span><span style="font-family:宋体">最终也是用</span><span style="font-family:Verdana">malloc/free</span><span style="font-family:宋体">的，所以只要截获前面一组即可）。对于其他的泄漏，可以采用类似的方法，截获住相应的分配和释放函数。比如，要检测</span><span style="font-family:Verdana">BSTR</span><span style="font-family:宋体">的泄漏，就需要截获</span><span style="font-family:Verdana">SysAllocString/SysFreeString</span><span style="font-family:宋体">；要检测</span><span style="font-family:Verdana">HMENU</span><span style="font-family:宋体">的泄漏，就需要截获</span><span style="font-family:Verdana">CreateMenu/ DestroyMenu</span><span style="font-family:宋体">。（有的资源的分配函数有多个，释放函数只有一个，比如，</span><span style="font-family:Verdana">SysAllocStringLen</span><span style="font-family:宋体">也可以用来分配</span><span style="font-family:Verdana">BSTR</span><span style="font-family:宋体">，这时就需要截获多个分配函数）</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　在</span><span style="font-family:Verdana">Windows</span><span style="font-family:宋体">平台下，检测内存泄漏的工具常用的一般有三种，</span><span style="font-family:Verdana">MS C-Runtime Library</span><span style="font-family:宋体">内建的检测功能；外挂式的检测工具，诸如，</span><span style="font-family:Verdana">Purify</span><span style="font-family:宋体">，</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">等；利用</span><span style="font-family:Verdana">Windows NT</span><span style="font-family:宋体">自带的</span><span style="font-family:Verdana">Performance Monitor</span><span style="font-family:宋体">。这三种工具各有优缺点，</span><span style="font-family:Verdana">MS C-Runtime Library</span><span style="font-family:宋体">虽然功能上较之外挂式的工具要弱，但是它是免费的；</span><span style="font-family:Verdana">Performance Monitor</span><span style="font-family:宋体">虽然无法标示出发生问题的代码，但是它能检测出隐式的内存泄漏的存在，这是其他两类工具无能为力的地方。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　以下我们详细讨论这三种检测工具：</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:12pt"><strong><span style="font-family:Verdana">2.3.3.1 VC</span><span style="font-family:黑体">下内存泄漏的检测方法</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　用</span><span style="font-family:Verdana">MFC</span><span style="font-family:宋体">开发的应用程序，在</span><span style="font-family:Verdana">DEBUG</span><span style="font-family:宋体">版模式下编译后，都会自动加入内存泄漏的检测代码。在程序结束后，如果发生了内存泄漏，在</span><span style="font-family:Verdana">Debug</span><span style="font-family:宋体">窗口中会显示出所有发生泄漏的内存块的信息，以下两行显示了一块被泄漏的内存块的信息：</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-family:Verdana; font-size:8pt">E:"TestMemLeak"TestDlg.cpp(70) : {59} normal block at 0x00881710, 200 bytes long.
</span></p><p><span style="color:#4b4b4b; font-family:Verdana; font-size:8pt">Data: &lt;abcdefghijklmnop&gt; 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F 70
</span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　第一行显示该内存块由</span><span style="font-family:Verdana">TestDlg.cpp</span><span style="font-family:宋体">文件，第</span><span style="font-family:Verdana">70</span><span style="font-family:宋体">行代码分配，地址在</span><span style="font-family:Verdana">0x00881710</span><span style="font-family:宋体">，大小为</span><span style="font-family:Verdana">200</span><span style="font-family:宋体">字节，</span><span style="font-family:Verdana">{59}</span><span style="font-family:宋体">是指调用内存分配函数的</span><span style="font-family:Verdana">Request Order</span><span style="font-family:宋体">，关于它的详细信息可以参见</span><span style="font-family:Verdana">MSDN</span><span style="font-family:宋体">中</span><span style="font-family:Verdana">_CrtSetBreakAlloc()</span><span style="font-family:宋体">的帮助。第二行显示该内存块前</span><span style="font-family:Verdana">16</span><span style="font-family:宋体">个字节的内容，尖括号内是以</span><span style="font-family:Verdana">ASCII</span><span style="font-family:宋体">方式显示，接着的是以</span><span style="font-family:Verdana">16</span><span style="font-family:宋体">进制方式显示。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　一般大家都误以为这些内存泄漏的检测功能是由</span><span style="font-family:Verdana">MFC</span><span style="font-family:宋体">提供的，其实不然。</span><span style="font-family:Verdana">MFC</span><span style="font-family:宋体">只是封装和利用了</span><span style="font-family:Verdana">MS C-Runtime Library</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">Debug Function</span><span style="font-family:宋体">。非</span><span style="font-family:Verdana">MFC</span><span style="font-family:宋体">程序也可以利用</span><span style="font-family:Verdana">MS C-Runtime Library</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">Debug Function</span><span style="font-family:宋体">加入内存泄漏的检测功能。</span><span style="font-family:Verdana">MS C-Runtime Library</span><span style="font-family:宋体">在实现</span><span style="font-family:Verdana">malloc/free</span><span style="font-family:宋体">，</span><span style="font-family:Verdana">strdup</span><span style="font-family:宋体">等函数时已经内建了内存泄漏的检测功能。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">注意观察一下由</span><span style="font-family:Verdana">MFC Application Wizard</span><span style="font-family:宋体">生成的项目，在每一个</span><span style="font-family:Verdana">cpp</span><span style="font-family:宋体">文件的头部都有这样一段宏定义：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">#ifdef _DEBUG
</span></p><p><span style="font-family:Verdana; font-size:8pt">#define new DEBUG_NEW
</span></p><p><span style="font-family:Verdana; font-size:8pt">#undef THIS_FILE
</span></p><p><span style="font-family:Verdana; font-size:8pt">static char THIS_FILE[] = __FILE__;
</span></p><p><span style="font-family:Verdana; font-size:8pt">#endif</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">有了这样的定义，在编译</span><span style="font-family:Verdana">DEBUG</span><span style="font-family:宋体">版时，出现在这个</span><span style="font-family:Verdana">cpp</span><span style="font-family:宋体">文件中的所有</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">都被替换成</span><span style="font-family:Verdana">DEBUG_NEW</span><span style="font-family:宋体">了。那么</span><span style="font-family:Verdana">DEBUG_NEW</span><span style="font-family:宋体">是什么呢？</span><span style="font-family:Verdana">DEBUG_NEW</span><span style="font-family:宋体">也是一个宏，以下摘自</span><span style="font-family:Verdana">afx.h</span><span style="font-family:宋体">，</span><span style="font-family:Verdana">1632</span><span style="font-family:宋体">行</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">#define DEBUG_NEW new(THIS_FILE, __LINE__)</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">所以如果有这样一行代码：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">char* p = new char[200];</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">经过宏替换就变成了：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">char* p = new( THIS_FILE, __LINE__)char[200];</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">根据</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">的标准，对于以上的</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">的使用方法，编译器会去找这样定义的</span><span style="font-family:Verdana">operator new</span><span style="font-family:宋体">：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">void* operator new(size_t, LPCSTR, int)</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">我们在</span><span style="font-family:Verdana">afxmem.cpp 63</span><span style="font-family:宋体">行找到了一个这样的</span><span style="font-family:Verdana">operator new?</span><span style="font-family:宋体">的实现</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">void* AFX_CDECL operator new(size_t nSize, LPCSTR lpszFileName, int nLine)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">return ::operator new(nSize, _NORMAL_BLOCK, lpszFileName, nLine);
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">void* __cdecl operator new(size_t nSize, int nType, LPCSTR lpszFileName, int nLine)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　…</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">pResult = _malloc_dbg(nSize, nType, lpszFileName, nLine);
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">if (pResult != NULL)
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">return pResult;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　…</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　第二个</span><span style="font-family:Verdana">operator new</span><span style="font-family:宋体">函数比较长，为了简单期间，我只摘录了部分。很显然最后的内存分配还是通过</span><span style="font-family:Verdana">_malloc_dbg</span><span style="font-family:宋体">函数实现的，这个函数属于</span><span style="font-family:Verdana">MS C-Runtime Library?</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">Debug Function</span><span style="font-family:宋体">。这个函数不但要求传入内存的大小，另外还有文件名和行号两个参数。文件名和行号就是用来记录此次分配是由哪一段代码造成的。如果这块内存在程序结束之前没有被释放，那么这些信息就会输出到</span><span style="font-family:Verdana">Debug</span><span style="font-family:宋体">窗口里。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　这里顺便提一下</span><span style="font-family:Verdana">THIS_FILE</span><span style="font-family:宋体">，</span><span style="font-family:Verdana">__FILE</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">__LINE__</span><span style="font-family:宋体">。</span><span style="font-family:Verdana">__FILE__</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">__LINE__</span><span style="font-family:宋体">都是编译器定义的宏。当碰到</span><span style="font-family:Verdana">__FILE__</span><span style="font-family:宋体">时，编译器会把</span><span style="font-family:Verdana">__FILE__</span><span style="font-family:宋体">替换成一个字符串，这个字符串就是当前在编译的文件的路径名。当碰到</span><span style="font-family:Verdana">__LINE__</span><span style="font-family:宋体">时，编译器会把</span><span style="font-family:Verdana">__LINE__</span><span style="font-family:宋体">替换成一个数字，这个数字就是当前这行代码的行号。在</span><span style="font-family:Verdana">DEBUG_NEW</span><span style="font-family:宋体">的定义中没有直接使用</span><span style="font-family:Verdana">__FILE__</span><span style="font-family:宋体">，而是用了</span><span style="font-family:Verdana">THIS_FILE</span><span style="font-family:宋体">，其目的是为了减小目标文件的大小。假设在某个</span><span style="font-family:Verdana">cpp</span><span style="font-family:宋体">文件中有</span><span style="font-family:Verdana">100</span><span style="font-family:宋体">处使用了</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">，如果直接使用</span><span style="font-family:Verdana">__FILE__</span><span style="font-family:宋体">，那编译器会产生</span><span style="font-family:Verdana">100</span><span style="font-family:宋体">个常量字符串，这</span><span style="font-family:Verdana">100</span><span style="font-family:宋体">个字符串都是飧</span><span style="font-family:Verdana">?/SPAN&gt;cpp</span><span style="font-family:宋体">文件的路径名，显然十分冗余。如果使用</span><span style="font-family:Verdana">THIS_FILE</span><span style="font-family:宋体">，编译器只会产生一个常量字符串，那</span><span style="font-family:Verdana">100</span><span style="font-family:宋体">处</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">的调用使用的都是指向常量字符串的指针。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　再次观察一下由</span><span style="font-family:Verdana">MFC Application Wizard</span><span style="font-family:宋体">生成的项目，我们会发现在</span><span style="font-family:Verdana">cpp</span><span style="font-family:宋体">文件中只对</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">做了映射，如果你在程序中直接使用</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">函数分配内存，调用</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">的文件名和行号是不会被记录下来的。如果这块内存发生了泄漏，</span><span style="font-family:Verdana">MS C-Runtime Library</span><span style="font-family:宋体">仍然能检测到，但是当输出这块内存块的信息，不会包含分配它的的文件名和行号。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">要在非</span><span style="font-family:Verdana">MFC</span><span style="font-family:宋体">程序中打开内存泄漏的检测功能非常容易，你只要在程序的入口处加入以下几行代码：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
</span></p><p><span style="font-family:Verdana; font-size:8pt">tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
</span></p><p><span style="font-family:Verdana; font-size:8pt">_CrtSetDbgFlag( tmpFlag );</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　这样，在程序结束的时候，也就是</span><span style="font-family:Verdana">winmain</span><span style="font-family:宋体">，</span><span style="font-family:Verdana">main</span><span style="font-family:宋体">或</span><span style="font-family:Verdana">dllmain</span><span style="font-family:宋体">函数返回之后，如果还有内存块没有释放，它们的信息会被打印到</span><span style="font-family:Verdana">Debug</span><span style="font-family:宋体">窗口里。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">如果你试着创建了一个非</span><span style="font-family:Verdana">MFC</span><span style="font-family:宋体">应用程序，而且在程序的入口处加入了以上代码，并且故意在程序中不释放某些内存块，你会在</span><span style="font-family:Verdana">Debug</span><span style="font-family:宋体">窗口里看到以下的信息：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">{47} normal block at 0x00C91C90, 200 bytes long.
</span></p><p><span style="font-family:Verdana; font-size:8pt">Data: &lt; &gt; 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　内存泄漏的确检测到了，但是和上面</span><span style="font-family:Verdana">MFC</span><span style="font-family:宋体">程序的例子相比，缺少了文件名和行号。对于一个比较大的程序，没有这些信息，解决问题将变得十分困难。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　为了能够知道泄漏的内存块是在哪里分配的，你需要实现类似</span><span style="font-family:Verdana">MFC</span><span style="font-family:宋体">的映射功能，把</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">，</span><span style="font-family:Verdana">maolloc</span><span style="font-family:宋体">等函数映射到</span><span style="font-family:Verdana">_malloc_dbg</span><span style="font-family:宋体">函数上。这里我不再赘述，你可以参考</span><span style="font-family:Verdana">MFC</span><span style="font-family:宋体">的源代码。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　由于</span><span style="font-family:Verdana">Debug Function</span><span style="font-family:宋体">实现在</span><span style="font-family:Verdana">MS C-RuntimeLibrary</span><span style="font-family:宋体">中，所以它只能检测到堆内存的泄漏，而且只限于</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">，</span><span style="font-family:Verdana">realloc</span><span style="font-family:宋体">或</span><span style="font-family:Verdana">strdup</span><span style="font-family:宋体">等分配的内存，而那些系统资源，比如</span><span style="font-family:Verdana">HANDLE</span><span style="font-family:宋体">，</span><span style="font-family:Verdana">GDI Object</span><span style="font-family:宋体">，或是不通过</span><span style="font-family:Verdana">C-Runtime Library</span><span style="font-family:宋体">分配的内存，比如</span><span style="font-family:Verdana">VARIANT</span><span style="font-family:宋体">，</span><span style="font-family:Verdana">BSTR</span><span style="font-family:宋体">的泄漏，它是无法检测到的，这是这种检测法的一个重大的局限性。另外，为了能记录内存块是在哪里分配的，源代码必须相应的配合，这在调试一些老的程序非常麻烦，毕竟修改源代码不是一件省心的事，这是这种检测法的另一个局限性。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">对于开发一个大型的程序，</span><span style="font-family:Verdana">MS C-Runtime Library</span><span style="font-family:宋体">提供的检测功能是远远不够的。接下来我们就看看外挂式的检测工具。我用的比较多的是</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">，一则因为它的功能比较全面，更重要的是它的稳定性。这类工具如果不稳定，反而会忙里添乱。到底是出自鼎鼎大名的</span><span style="font-family:Verdana">NuMega</span><span style="font-family:宋体">，我用下来基本上没有什么大问题。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:12pt"><strong><span style="font-family:Verdana">2.3.3.2?</span><span style="font-family:黑体">使用</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:黑体">检测内存泄漏</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">采用一种被称为</span><span style="font-family:Verdana">?Code Injection</span><span style="font-family:宋体">的技术，来截获对分配内存和释放内存的函数的调用。简单地说，当你的程序开始运行时，</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">DLL</span><span style="font-family:宋体">被自动载入进程的地址空间（这可以通过</span><span style="font-family:Verdana">system-level</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">Hook</span><span style="font-family:宋体">实现），然后它会修改进程中对内存分配和释放的函数调用，让这些调用首先转入它的代码，然后再执行原来的代码。</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">在做这些动作的时，无须修改被调试程序的源代码或工程配置文件，这使得使用它非常的简便、直接。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　这里我们以</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">函数为例，截获其他的函数方法与此类似。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　需要被截获的函数可能在</span><span style="font-family:Verdana">DLL</span><span style="font-family:宋体">中，也可能在程序的代码里。比如，如果静态连结</span><span style="font-family:Verdana">C-Runtime Library</span><span style="font-family:宋体">，那么</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">函数的代码会被连结到程序里。为了截获住对这类函数的调用，</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">会动态修改这些函数的指令。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">以下两段汇编代码，一段没有</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">介入，另一段则有</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">的介入：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">126: _CRTIMP void * __cdecl malloc (
</span></p><p><span style="font-family:Verdana; font-size:8pt">127: size_t nSize
</span></p><p><span style="font-family:Verdana; font-size:8pt">128: )
</span></p><p><span style="font-family:Verdana; font-size:8pt">129: {
</span></p><p><span style="font-family:Verdana; font-size:8pt">00403C10 push ebp
</span></p><p><span style="font-family:Verdana; font-size:8pt">00403C11 mov ebp,esp
</span></p><p><span style="font-family:Verdana; font-size:8pt">130: return _nh_malloc_dbg(nSize, _newmode, _NORMAL_BLOCK, NULL, 0);
</span></p><p><span style="font-family:Verdana; font-size:8pt">00403C13 push 0
</span></p><p><span style="font-family:Verdana; font-size:8pt">00403C15 push 0
</span></p><p><span style="font-family:Verdana; font-size:8pt">00403C17 push 1
</span></p><p><span style="font-family:Verdana; font-size:8pt">00403C19 mov eax,[__newmode (0042376c)]
</span></p><p><span style="font-family:Verdana; font-size:8pt">00403C1E push eax
</span></p><p><span style="font-family:Verdana; font-size:8pt">00403C1F mov ecx,dword ptr [nSize]
</span></p><p><span style="font-family:Verdana; font-size:8pt">00403C22 push ecx
</span></p><p><span style="font-family:Verdana; font-size:8pt">00403C23 call _nh_malloc_dbg (00403c80)
</span></p><p><span style="font-family:Verdana; font-size:8pt">00403C28 add esp,14h
</span></p><p><span style="font-family:Verdana; font-size:8pt">131: }</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">以下这一段代码有</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">介入：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">126: _CRTIMP void * __cdecl malloc (
</span></p><p><span style="font-family:Verdana; font-size:8pt">127: size_t nSize
</span></p><p><span style="font-family:Verdana; font-size:8pt">128: )
</span></p><p><span style="font-family:Verdana; font-size:8pt">129: {
</span></p><p><span style="font-family:Verdana; font-size:8pt">00403C10 jmp 01F41EC8
</span></p><p><span style="font-family:Verdana; font-size:8pt">00403C15 push 0
</span></p><p><span style="font-family:Verdana; font-size:8pt">00403C17 push 1
</span></p><p><span style="font-family:Verdana; font-size:8pt">00403C19 mov eax,[__newmode (0042376c)]
</span></p><p><span style="font-family:Verdana; font-size:8pt">00403C1E push eax
</span></p><p><span style="font-family:Verdana; font-size:8pt">00403C1F mov ecx,dword ptr [nSize]
</span></p><p><span style="font-family:Verdana; font-size:8pt">00403C22 push ecx
</span></p><p><span style="font-family:Verdana; font-size:8pt">00403C23 call _nh_malloc_dbg (00403c80)
</span></p><p><span style="font-family:Verdana; font-size:8pt">00403C28 add esp,14h
</span></p><p><span style="font-family:Verdana; font-size:8pt">131: }</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　当</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">介入后，函数</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">的前三条汇编指令被替换成一条</span><span style="font-family:Verdana">jmp</span><span style="font-family:宋体">指令，原来的三条指令被搬到地址</span><span style="font-family:Verdana">01F41EC8</span><span style="font-family:宋体">处了。当程序进入</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">后先</span><span style="font-family:Verdana">jmp</span><span style="font-family:宋体">到</span><span style="font-family:Verdana">01F41EC8</span><span style="font-family:宋体">，执行原来的三条指令，然后就是</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">的天下了。大致上它会先记录函数的返回地址（函数的返回地址在</span><span style="font-family:Verdana">stack</span><span style="font-family:宋体">上，所以很容易修改），然后把返回地址指向属于</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">的代码，接着跳到</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">函数原来的指令，也就是在</span><span style="font-family:Verdana">00403c15</span><span style="font-family:宋体">的地方。当</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">函数结束的时候，由于返回地址被修改，它会返回到</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">的代码中，此时</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">会记录由</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">分配的内存的指针，然后再跳转到到原来的返回地址去。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　如果内存分配</span><span style="font-family:Verdana">/</span><span style="font-family:宋体">释放函数在</span><span style="font-family:Verdana">DLL</span><span style="font-family:宋体">中，</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">则采用另一种方法来截获对这些函数的调用。</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">通过修改程序的</span><span style="font-family:Verdana">DLL Import Table</span><span style="font-family:宋体">让</span><span style="font-family:Verdana">table</span><span style="font-family:宋体">中的函数地址指向自己的地址，以达到截获的目的。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">截获住这些分配和释放函数，</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">就能记录被分配的内存或资源的生命周期。接下来的问题是如何与源代码相关，也就是说当</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">检测到内存泄漏，它如何报告这块内存块是哪段代码分配的。答案是调试信息（</span><span style="font-family:Verdana">Debug Information</span><span style="font-family:宋体">）。当我们编译一个</span><span style="font-family:Verdana">Debug</span><span style="font-family:宋体">版的程序时，编译器会把源代码和二进制代码之间的对应关系记录下来，放到一个单独的文件里</span><span style="font-family:Verdana">(.pdb)</span><span style="font-family:宋体">或者直接连结进目标程序，通过直接读取调试信息就能得到分配某块内存的源代码在哪个文件，哪一行上。使用</span><span style="font-family:Verdana">Code Injection</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">Debug Information</span><span style="font-family:宋体">，使</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">不但能记录呼叫分配函数的源代码的位置，而且还能记录分配时的</span><span style="font-family:Verdana">Call Stack</span><span style="font-family:宋体">，以及</span><span style="font-family:Verdana">Call Stack</span><span style="font-family:宋体">上的函数的源代码位置。这在使用像</span><span style="font-family:Verdana">MFC</span><span style="font-family:宋体">这样的类库时非常有用，以下我用一个例子来说明：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">void ShowXItemMenu()
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　…</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">CMenu menu;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">menu.CreatePopupMenu();
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">//add menu items.
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">menu.TrackPropupMenu();
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　…</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">void ShowYItemMenu( )
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　…</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">CMenu menu;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">menu.CreatePopupMenu();
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">//add menu items.
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">menu.TrackPropupMenu();
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">menu.Detach();//this will cause HMENU leak
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　…</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">BOOL CMenu::CreatePopupMenu()
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　…</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">hMenu = CreatePopupMenu();
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　…</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">当调用</span><span style="font-family:Verdana">ShowYItemMenu()</span><span style="font-family:宋体">时，我们故意造成</span><span style="font-family:Verdana">HMENU</span><span style="font-family:宋体">的泄漏。但是，对于</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">来说被泄漏的</span><span style="font-family:Verdana">HMENU</span><span style="font-family:宋体">是在</span><span style="font-family:Verdana">class CMenu::CreatePopupMenu()</span><span style="font-family:宋体">中分配的。假设的你的程序有许多地方使用了</span><span style="font-family:Verdana">CMenu</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">CreatePopupMenu()</span><span style="font-family:宋体">函数，如</span><span style="font-family:Verdana">CMenu::CreatePopupMenu()</span><span style="font-family:宋体">造成的，你依然无法确认问题的根结到底在哪里，在</span><span style="font-family:Verdana">ShowXItemMenu()</span><span style="font-family:宋体">中还是在</span><span style="font-family:Verdana">ShowYItemMenu()</span><span style="font-family:宋体">中，或者还有其它的地方也使用了</span><span style="font-family:Verdana">CreatePopupMenu()</span><span style="font-family:宋体">？有了</span><span style="font-family:Verdana">Call Stack</span><span style="font-family:宋体">的信息，问题就容易了。</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">会如下报告泄漏的</span><span style="font-family:Verdana">HMENU</span><span style="font-family:宋体">的信息：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">Function
</span></p><p><span style="font-family:Verdana; font-size:8pt">File
</span></p><p><span style="font-family:Verdana; font-size:8pt">Line
</span></p><p><span style="font-family:Verdana; font-size:8pt">CMenu::CreatePopupMenu
</span></p><p><span style="font-family:Verdana; font-size:8pt">E:"8168"vc98"mfc"mfc"include"afxwin1.inl
</span></p><p><span style="font-family:Verdana; font-size:8pt">1009
</span></p><p><span style="font-family:Verdana; font-size:8pt">ShowYItemMenu
</span></p><p><span style="font-family:Verdana; font-size:8pt">E:"testmemleak"mytest.cpp
</span></p><p><span style="font-family:Verdana; font-size:8pt">100</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　这里省略了其他的函数调用</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　如此，我们很容易找到发生问题的函数是</span><span style="font-family:Verdana">ShowYItemMenu()</span><span style="font-family:宋体">。当使用</span><span style="font-family:Verdana">MFC</span><span style="font-family:宋体">之类的类库编程时，大部分的</span><span style="font-family:Verdana">API</span><span style="font-family:宋体">调用都被封装在类库的</span><span style="font-family:Verdana">class</span><span style="font-family:宋体">里，有了</span><span style="font-family:Verdana">Call Stack</span><span style="font-family:宋体">信息，我们就可以非常容易的追踪到真正发生泄漏的代码。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　记录</span><span style="font-family:Verdana">Call Stack</span><span style="font-family:宋体">信息会使程序的运行变得非常慢，因此默认情况下</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">不会记录</span><span style="font-family:Verdana">Call Stack</span><span style="font-family:宋体">信息。可以按照以下的步骤打开记录</span><span style="font-family:Verdana">Call Stack</span><span style="font-family:宋体">信息的选项开关：</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">1.?</span><span style="font-family:宋体">打开菜单：</span><span style="font-family:Verdana">BoundsChecker|Setting</span><span style="font-family:宋体">…</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">2.?</span><span style="font-family:宋体">在</span><span style="font-family:Verdana">Error Detection</span><span style="font-family:宋体">页中，在</span><span style="font-family:Verdana">Error Detection Scheme</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">List</span><span style="font-family:宋体">中选择</span><span style="font-family:Verdana">Custom
</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">3.?</span><span style="font-family:宋体">在</span><span style="font-family:Verdana">Category</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">Combox</span><span style="font-family:宋体">中选择</span><span style="font-family:Verdana">?Pointer and leak error check
</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">4.?</span><span style="font-family:宋体">钩上</span><span style="font-family:Verdana">Report Call Stack</span><span style="font-family:宋体">复选框</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">5.?</span><span style="font-family:宋体">点击</span><span style="font-family:Verdana">Ok
</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　基于</span><span style="font-family:Verdana">Code Injection</span><span style="font-family:宋体">，</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">还提供了</span><span style="font-family:Verdana">API Parameter</span><span style="font-family:宋体">的校验功能，</span><span style="font-family:Verdana">memory over run</span><span style="font-family:宋体">等功能。这些功能对于程序的开发都非常有益。由于这些内容不属于本文的主题，所以不在此详述了。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">尽管</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">的功能如此强大，但是面对隐式内存泄漏仍然显得苍白无力。所以接下来我们看看如何用</span><span style="font-family:Verdana">Performance Monitor</span><span style="font-family:宋体">检测内存泄漏。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:12pt"><strong><span style="font-family:Verdana">2.3.3.3?</span><span style="font-family:黑体">使用</span><span style="font-family:Verdana">Performance Monitor</span><span style="font-family:黑体">检测内存泄漏</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">NT</span><span style="font-family:宋体">的内核在设计过程中已经加入了系统监视功能，比如</span><span style="font-family:Verdana">CPU</span><span style="font-family:宋体">的使用率，内存的使用情况，</span><span style="font-family:Verdana">I/O</span><span style="font-family:宋体">操作的频繁度等都作为一个个</span><span style="font-family:Verdana">Counter</span><span style="font-family:宋体">，应用程序可以通过读取这些</span><span style="font-family:Verdana">Counter</span><span style="font-family:宋体">了解整个系统的或者某个进程的运行状况。</span><span style="font-family:Verdana">Performance Monitor</span><span style="font-family:宋体">就是这样一个应用程序。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　为了检测内存泄漏，我们一般可以监视</span><span style="font-family:Verdana">Process</span><span style="font-family:宋体">对象的</span><span style="font-family:Verdana">Handle Count</span><span style="font-family:宋体">，</span><span style="font-family:Verdana">Virutal Bytes</span><span style="font-family:宋体">和</span><span style="font-family:Verdana">Working Set</span><span style="font-family:宋体">三个</span><span style="font-family:Verdana">Counter</span><span style="font-family:宋体">。</span><span style="font-family:Verdana">Handle Count</span><span style="font-family:宋体">记录了进程当前打开的</span><span style="font-family:Verdana">HANDLE</span><span style="font-family:宋体">的个数，监视这个</span><span style="font-family:Verdana">Counter</span><span style="font-family:宋体">有助于我们发现程序是否有</span><span style="font-family:Verdana">Handle</span><span style="font-family:宋体">泄漏；</span><span style="font-family:Verdana">Virtual Bytes</span><span style="font-family:宋体">记录了该进程当前在虚地址空间上使用的虚拟内存的大小，</span><span style="font-family:Verdana">NT</span><span style="font-family:宋体">的内存分配采用了两步走的方法，首先，在虚地址空间上保留一段空间，这时操作系统并没有分配物理内存，只是保留了一段地址。然后，再提交这段空间，这时操作系统才会分配物理内存。所以，</span><span style="font-family:Verdana">Virtual Bytes</span><span style="font-family:宋体">一般总大于程序的</span><span style="font-family:Verdana">Working Set</span><span style="font-family:宋体">。监视</span><span style="font-family:Verdana">Virutal Bytes</span><span style="font-family:宋体">可以帮助我们发现一些系统底层的问题</span><span style="font-family:Verdana">; Working Set</span><span style="font-family:宋体">记录了操作系统为进程已提交的内存的总量，这个值和程序申请的内存总量存在密切的关系，如果程序存在内存的泄漏这个值会持续增加，但是</span><span style="font-family:Verdana">Virtual Bytes</span><span style="font-family:宋体">却是跳跃式增加的。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　监视这些</span><span style="font-family:Verdana">Counter</span><span style="font-family:宋体">可以让我们了解进程使用内存的情况，如果发生了泄漏，即使是隐式内存泄漏，这些</span><span style="font-family:Verdana">Counter</span><span style="font-family:宋体">的值也会持续增加。但是，我们知道有问题却不知道哪里有问题，所以一般使用</span><span style="font-family:Verdana">Performance Monitor</span><span style="font-family:宋体">来验证是否有内存泄漏，而使用</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">来找到和解决。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　当</span><span style="font-family:Verdana">Performance Monitor</span><span style="font-family:宋体">显示有内存泄漏，而</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">却无法检测到，这时有两种可能：第一种，发生了偶发性内存泄漏。这时你要确保使用</span><span style="font-family:Verdana">Performance Monitor</span><span style="font-family:宋体">和使用</span><span style="font-family:Verdana">BoundsChecker</span><span style="font-family:宋体">时，程序的运行环境和操作方法是一致的。第二种，发生了隐式的内存泄漏。这时你要重新审查程序的设计，然后仔细研究</span><span style="font-family:Verdana">Performance Monitor</span><span style="font-family:宋体">记录的</span><span style="font-family:Verdana">Counter</span><span style="font-family:宋体">的值的变化图，分析其中的变化和程序运行逻辑的关系，找到一些可能的原因。这是一个痛苦的过程，充满了假设、猜想、验证、失败，但这也是一个积累经验的绝好机会。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-family:黑体; font-size:24pt"><strong>3?探讨C++内存回收
</strong></span></p><p><span style="color:#4b4b4b; font-size:18pt"><strong><span style="font-family:Verdana">3.1 C++</span><span style="font-family:黑体">内存对象大会战</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　如果一个人自称为程序高手，却对内存一无所知，那么我可以告诉你，他一定在吹牛。用</span><span style="font-family:Verdana">C</span><span style="font-family:宋体">或</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">写程序，需要更多地关注内存，这不仅仅是因为内存的分配是否合理直接影响着程序的效率和性能，更为主要的是，当我们操作内存的时候一不小心就会出现问题，而且很多时候，这些问题都是不易发觉的，比如内存泄漏，比如悬挂指针。笔者今天在这里并不是要讨论如何避免这些问题，而是想从另外一个角度来认识</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">内存对象。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　我们知道，</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">将内存划分为三个逻辑区域：堆、栈和静态存储区。既然如此，我称位于它们之中的对象分别为堆对象，栈对象以及静态对象。那么这些不同的内存对象有什么区别了？堆对象和栈对象各有什么优劣了？如何禁止创建堆对象或栈对象了？这些便是今天的主题。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:15pt"><strong><span style="font-family:Verdana">3.1.1?</span><span style="font-family:宋体">基本概念</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　先来看看栈。栈，一般用于存放局部变量或对象，如我们在函数定义中用类似下面语句声明的对象：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">Type stack_object ;?</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">stack_object</span><span style="font-family:宋体">便是一个栈对象，它的生命期是从定义点开始，当所在函数返回时，生命结束。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　另外，几乎所有的临时对象都是栈对象。比如，下面的函数定义：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-size:8pt"><span style="font-family:Verdana">Type fun(Type object);//</span><span style="color:red; font-family:宋体">此函数在参数传入时生成一个临时变量，在返回值时，再生成一个临时变量，并将这个临时变量复制给外面的变量。</span></span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　这个函数至少产生两个临时对象，首先，参数是按值传递的，所以会调用拷贝构造函数生成一个临时对象</span><span style="font-family:Verdana">object_copy1?</span><span style="font-family:宋体">，在函数内部使用的不是使用的不是</span><span style="font-family:Verdana">object</span><span style="font-family:宋体">，而是</span><span style="font-family:Verdana">object_copy1</span><span style="font-family:宋体">，自然，</span><span style="font-family:Verdana">object_copy1</span><span style="font-family:宋体">是一个栈对象，它在函数返回时被释放；还有这个函数是值返回的，在函数返回时，如果我们不考虑返回值优化（</span><span style="font-family:Verdana">NRV</span><span style="font-family:宋体">），那么也会产生一个临时对象</span><span style="font-family:Verdana">object_copy2</span><span style="font-family:宋体">，这个临时对象会在函数返回后一段时间内被释放。比如某个函数中有如下代码：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-size:8pt"><span style="font-family:Verdana">Type tt ,result ; //</span><span style="font-family:宋体">生成两个栈对象</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">tt = fun(tt); //</span><span style="font-family:宋体">函数返回时，生成的是一个临时对象</span><span style="font-family:Verdana">object_copy2</span></span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　上面的第二个语句的执行情况是这样的，首先函数</span><span style="font-family:Verdana">fun</span><span style="font-family:宋体">返回时生成一个临时对象</span><span style="font-family:Verdana">object_copy2</span><span style="font-family:宋体">，然后再调用赋值运算符执行</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-size:8pt"><span style="font-family:Verdana">tt = object_copy2 ; //</span><span style="font-family:宋体">调用赋值运算符</span></span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　看到了吗？编译器在我们毫无知觉的情况下，为我们生成了这么多临时对象，而生成这些临时对象的时间和空间的开销可能是很大的，所以，你也许明白了，为什么对于"大"对象最好用</span><span style="font-family:Verdana">const</span><span style="font-family:宋体">引用传递代替按值进行函数参数传递了。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　接下来，看看堆。堆，又叫自由存储区，它是在程序执行的过程中动态分配的，所以它最大的特性就是动态性。在</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">中，所有堆对象的创建和销毁都要由程序员负责，所以，如果处理不好，就会发生内存问题。如果分配了堆对象，却忘记了释放，就会产生内存泄漏；而如果已释放了对象，却没有将相应的指针置为</span><span style="font-family:Verdana">NULL</span><span style="font-family:宋体">，该指针就是所谓的"悬挂指针"，再度使用此指针时，就会出现非法访问，严重时就导致程序崩溃。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　那么，</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">中是怎样分配堆对象的？唯一的方法就是用</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">（当然，用类</span><span style="font-family:Verdana">malloc</span><span style="font-family:宋体">指令也可获得</span><span style="font-family:Verdana">C</span><span style="font-family:宋体">式堆内存），只要使用</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">，就会在堆中分配一块内存，并且返回指向该堆对象的指针。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="font-size:8pt"><span style="color:#4b4b4b; font-family:宋体">　　再来看看静态存储区。</span><span style="color:red; font-family:宋体; background-color:yellow">所有的<strong>静态对象、全局对象</strong>都于静态存储区分配。</span><span style="color:#4b4b4b"><span style="font-family:宋体">关于全局对象，是在</span><span style="font-family:Verdana">main()</span><span style="font-family:宋体">函数执行前就分配好了的。其实，在</span><span style="font-family:Verdana">main()</span><span style="font-family:宋体">函数中的显示代码执行之前，会调用一个由编译器生成的</span><span style="font-family:Verdana">_main()</span><span style="font-family:宋体">函数，而</span><span style="font-family:Verdana">_main()</span><span style="font-family:宋体">函数会进行所有全局对象的的构造及初始化工作。而在</span><span style="font-family:Verdana">main()</span><span style="font-family:宋体">函数结束之前，会调用由编译器生成的</span><span style="font-family:Verdana">exit</span><span style="font-family:宋体">函数，来释放所有的全局对象。比如下面的代码：</span><span style="font-family:Verdana">
				</span></span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-size:8pt"><span style="font-family:Verdana">void main</span><span style="font-family:宋体">（</span><span style="font-family:Verdana">void</span><span style="font-family:宋体">）</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　…</span><span style="font-family:Verdana">?</span><span style="font-family:宋体">…</span><span style="font-family:Verdana">//?</span><span style="font-family:宋体">显式代码</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　实际上，被转化成这样：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-size:8pt"><span style="font-family:Verdana">void main</span><span style="font-family:宋体">（</span><span style="font-family:Verdana">void</span><span style="font-family:宋体">）</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">_main</span><span style="font-family:宋体">（）</span><span style="font-family:Verdana">; //</span><span style="font-family:宋体">隐式代码，由编译器产生，用以构造所有全局对象</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　…</span><span style="font-family:Verdana">?</span><span style="font-family:宋体">…</span><span style="font-family:Verdana">?//?</span><span style="font-family:宋体">显式代码</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　…</span><span style="font-family:Verdana">?</span><span style="font-family:宋体">…</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">exit</span><span style="font-family:宋体">（）</span><span style="font-family:Verdana">?; //?</span><span style="font-family:宋体">隐式代码，由编译器产生，用以释放所有全局对象</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}</span></p></td></tr></tbody></table></div><p><span style="font-size:8pt"><span style="color:#4b4b4b"><span style="font-family:宋体">　　所以，知道了这个之后，便可以由此引出一些技巧，如，假设我们要在</span><span style="font-family:Verdana">main()</span><span style="font-family:宋体">函数执行之前做某些准备工作，那么我们可以将这些准备工作写到一个自定义的全局对象的构造函数中，这样，在</span><span style="font-family:Verdana">main()</span><span style="font-family:宋体">函数的显式代码执行之前，这个全局对象的构造函数会被调用，执行预期的动作，这样就达到了我们的目的。</span><span style="font-family:Verdana">?</span><span style="font-family:宋体">刚才讲的是静态存储区中的全局对象，那么，局部静态对象了？局部静态对象通常也是在函数中定义的，就像栈对象一样，只不过，其前面多了个</span><span style="font-family:Verdana">static</span><span style="font-family:宋体">关键字。</span></span><span style="color:red"><span style="font-family:宋体; background-color:yellow">局部静态对象的生命期是从其所在函数第一次被调用，更确切地说，是当第一次执行到该静态对象的声明代码时，产生该静态局部对象，直到整个程序结束时，才销毁该对象。</span><span style="font-family:Verdana">
				</span></span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　还有一种静态对象，那就是它作为</span><span style="font-family:Verdana">class</span><span style="font-family:宋体">的静态成员。考虑这种情况时，就牵涉了一些较复杂的问题。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　第一个问题是</span><span style="font-family:Verdana">class</span><span style="font-family:宋体">的静态成员对象的生命期，</span><span style="font-family:Verdana">class</span><span style="font-family:宋体">的静态成员对象随着第一个</span><span style="font-family:Verdana">class object</span><span style="font-family:宋体">的产生而产生，在整个程序结束时消亡。也就是有这样的情况存在，在程序中我们定义了一个</span><span style="font-family:Verdana">class</span><span style="font-family:宋体">，该类中有一个静态对象作为成员，但是在程序执行过程中，如果我们没有创建任何一个该</span><span style="font-family:Verdana">class object</span><span style="font-family:宋体">，那么也就不会产生该</span><span style="font-family:Verdana">class</span><span style="font-family:宋体">所包含的那个静态对象。还有，如果创建了多个</span><span style="font-family:Verdana">class object</span><span style="font-family:宋体">，那么所有这些</span><span style="font-family:Verdana">object</span><span style="font-family:宋体">都共享那个静态对象成员。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　第二个问题是，当出现下列情况时：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">?class Base
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">public:
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">static Type s_object ;
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">class Derived1 : public Base / /?</span><span style="font-family:宋体">公共继承</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　…</span><span style="font-family:Verdana">?</span><span style="font-family:宋体">…</span><span style="font-family:Verdana">// other data
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">class Derived2 : public Base / /?</span><span style="font-family:宋体">公共继承</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　…</span><span style="font-family:Verdana">?</span><span style="font-family:宋体">…</span><span style="font-family:Verdana">// other data
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}
</span></p><p><span style="font-family:Verdana; font-size:8pt">Base example ;
</span></p><p><span style="font-family:Verdana; font-size:8pt">Derivde1 example1 ;
</span></p><p><span style="font-family:Verdana; font-size:8pt">Derivde2 example2 ;
</span></p><p><span style="font-family:Verdana; font-size:8pt"><strong>example.s_object = …… ;</strong>
							</span></p><p><span style="font-family:Verdana; font-size:8pt"><strong>example1.s_object = …… ;</strong>
							</span></p><p><span style="font-family:Verdana; font-size:8pt"><strong>example2.s_object = …… ;?</strong></span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　请注意上面标为黑体的三条语句，它们所访问的</span><span style="font-family:Verdana">s_object</span><span style="font-family:宋体">是同一个对象吗？答案是肯定的，它们的确是指向同一个对象，这听起来不像是真的，是吗？但这是事实，你可以自己写段简单的代码验证一下。我要做的是来解释为什么会这样？</span><span style="font-family:Verdana">?</span><span style="font-family:宋体">我们知道，当一个类比如</span><span style="font-family:Verdana">Derived1</span><span style="font-family:宋体">，从另一个类比如</span><span style="font-family:Verdana">Base</span><span style="font-family:宋体">继承时，那么，可以看作一个</span><span style="font-family:Verdana">Derived1</span><span style="font-family:宋体">对象中含有一个</span><span style="font-family:Verdana">Base</span><span style="font-family:宋体">型的对象，这就是一个</span><span style="font-family:Verdana">subobject</span><span style="font-family:宋体">。一个</span><span style="font-family:Verdana">Derived1</span><span style="font-family:宋体">对象的大致内存布局如下：</span><span style="font-family:Verdana">
			</span></span></p><p>　　
?</p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　让我们想想，当我们将一个</span><span style="font-family:Verdana">Derived1</span><span style="font-family:宋体">型的对象传给一个接受非引用</span><span style="font-family:Verdana">Base</span><span style="font-family:宋体">型参数的函数时会发生切割，那么是怎么切割的呢？相信现在你已经知道了，那就是仅仅取出了</span><span style="font-family:Verdana">Derived1</span><span style="font-family:宋体">型的对象中的</span><span style="font-family:Verdana">subobject</span><span style="font-family:宋体">，而忽略了所有</span><span style="font-family:Verdana">Derived1</span><span style="font-family:宋体">自定义的其它数据成员，然后将这个</span><span style="font-family:Verdana">subobject</span><span style="font-family:宋体">传递给函数（实际上，函数中使用的是这个</span><span style="font-family:Verdana">subobject</span><span style="font-family:宋体">的拷贝）。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　所有继承</span><span style="font-family:Verdana">Base</span><span style="font-family:宋体">类的派生类的对象都含有一个</span><span style="font-family:Verdana">Base</span><span style="font-family:宋体">型的</span><span style="font-family:Verdana">subobject</span><span style="font-family:宋体">（这是能用</span><span style="font-family:Verdana">Base</span><span style="font-family:宋体">型指针指向一个</span><span style="font-family:Verdana">Derived1</span><span style="font-family:宋体">对象的关键所在，自然也是多态的关键了），而所有的</span><span style="font-family:Verdana">subobject</span><span style="font-family:宋体">和所有</span><span style="font-family:Verdana">Base</span><span style="font-family:宋体">型的对象都共用同一个</span><span style="font-family:Verdana">s_object</span><span style="font-family:宋体">对象，自然，从</span><span style="font-family:Verdana">Base</span><span style="font-family:宋体">类派生的整个继承体系中的类的实例都会共用同一个</span><span style="font-family:Verdana">s_object</span><span style="font-family:宋体">对象了。上面提到的</span><span style="font-family:Verdana">example</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">example1</span><span style="font-family:宋体">、</span><span style="font-family:Verdana">example2</span><span style="font-family:宋体">的对象布局如下图所示：</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:16pt"><strong><span style="font-family:Verdana">3.1.2?</span><span style="font-family:宋体">三种内存对象的比较</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　栈对象的优势是在适当的时候自动生成，又在适当的时候自动销毁，不需要程序员操心；而且栈对象的创建速度一般较堆对象快，因为分配堆对象时，会调用</span><span style="font-family:Verdana">operator new</span><span style="font-family:宋体">操作，</span><span style="font-family:Verdana">operator new</span><span style="font-family:宋体">会采用某种内存空间搜索算法，而该搜索过程可能是很费时间的，产生栈对象则没有这么麻烦，它仅仅需要移动栈顶指针就可以了。但是要注意的是，通常栈空间容量比较小，一般是</span><span style="font-family:Verdana">1MB</span><span style="font-family:宋体">～</span><span style="font-family:Verdana">2MB</span><span style="font-family:宋体">，所以体积比较大的对象不适合在栈中分配。特别要注意递归函数中最好不要使用栈对象，因为随着递归调用深度的增加，所需的栈空间也会线性增加，当所需栈空间不够时，便会导致栈溢出，这样就会产生运行时错误。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　堆对象，其产生时刻和销毁时刻都要程序员精确定义，也就是说，程序员对堆对象的生命具有完全的控制权。我们常常需要这样的对象，比如，我们需要创建一个对象，能够被多个函数所访问，但是又不想使其成为全局的，那么这个时候创建一个堆对象无疑是良好的选择，然后在各个函数之间传递这个堆对象的指针，便可以实现对该对象的共享。另外，相比于栈空间，堆的容量要大得多。实际上，当物理内存不够时，如果这时还需要生成新的堆对象，通常不会产生运行时错误，而是系统会使用虚拟内存来扩展实际的物理内存。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">接下来看看</span><span style="font-family:Verdana">static</span><span style="font-family:宋体">对象。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　首先是全局对象。全局对象为类间通信和函数间通信提供了一种最简单的方式，虽然这种方式并不优雅。一般而言，在完全的面向对象语言中，是不存在全局对象的，比如</span><span style="font-family:Verdana">C#</span><span style="font-family:宋体">，因为全局对象意味着不安全和高耦合，在程序中过多地使用全局对象将大大降低程序的健壮性、稳定性、可维护性和可复用性。</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">也完全可以剔除全局对象，但是最终没有，我想原因之一是为了兼容</span><span style="font-family:Verdana">C</span><span style="font-family:宋体">。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="font-size:8pt"><span style="color:#4b4b4b; font-family:宋体">　　其次是类的静态成员，上面已经提到，</span><span style="color:red; font-family:宋体; background-color:yellow">基类及其派生类的所有对象都共享这个静态成员对象</span><span style="color:#4b4b4b"><span style="font-family:宋体">，所以当需要在这些</span><span style="font-family:Verdana">class</span><span style="font-family:宋体">之间或这些</span><span style="font-family:Verdana">class objects</span><span style="font-family:宋体">之间进行数据共享或通信时，这样的静态成员无疑是很好的选择。</span><span style="font-family:Verdana">
				</span></span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　接着是静态局部对象，主要可用于保存该对象所在函数被屡次调用期间的中间状态，其中一个最显著的例子就是递归函数，我们都知道递归函数是自己调用自己的函数，如果在递归函数中定义一个</span><span style="font-family:Verdana">nonstatic</span><span style="font-family:宋体">局部对象，那么当递归次数相当大时，所产生的开销也是巨大的。这是因为</span><span style="font-family:Verdana">nonstatic</span><span style="font-family:宋体">局部对象是栈对象，每递归调用一次，就会产生一个这样的对象，每返回一次，就会释放这个对象，而且，这样的对象只局限于当前调用层，对于更深入的嵌套层和更浅露的外层，都是不可见的。每个层都有自己的局部对象和参数。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　在递归函数设计中，可以使用</span><span style="font-family:Verdana">static</span><span style="font-family:宋体">对象替代</span><span style="font-family:Verdana">nonstatic</span><span style="font-family:宋体">局部对象（即栈对象），这不仅可以减少每次递归调用和返回时产生和释放</span><span style="font-family:Verdana">nonstatic</span><span style="font-family:宋体">对象的开销，而且</span><span style="font-family:Verdana">static</span><span style="font-family:宋体">对象还可以保存递归调用的中间状态，并且可为各个调用层所访问。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:16pt"><strong><span style="font-family:Verdana">3.1.3?</span><span style="font-family:宋体">使用栈对象的意外收获</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　前面已经介绍到，栈对象是在适当的时候创建，然后在适当的时候自动释放的，也就是栈对象有自动管理功能。那么栈对象会在什么会自动释放了？第一，在其生命期结束的时候；第二，在其所在的函数发生异常的时候。你也许说，这些都很正常啊，没什么大不了的。是的，没什么大不了的。但是只要我们再深入一点点，也许就有意外的收获了。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　栈对象，自动释放时，会调用它自己的析构函数。如果我们在栈对象中封装资源，而且在栈对象的析构函数中执行释放资源的动作，那么就会使资源泄漏的概率大大降低，因为栈对象可以自动的释放资源，即使在所在函数发生异常的时候。实际的过程是这样的：函数抛出异常时，会发生所谓的</span><span style="font-family:Verdana">stack_unwinding</span><span style="font-family:宋体">（堆栈回滚），即堆栈会展开，由于是栈对象，自然存在于栈中，所以在堆栈回滚的过程中，栈对象的析构函数会被执行，从而释放其所封装的资源。除非，除非在析构函数执行的过程中再次抛出异常――而这种可能性是很小的，所以用栈对象封装资源是比较安全的。基于此认识，我们就可以创建一个自己的句柄或代理来封装资源了。智能指针（</span><span style="font-family:Verdana">auto_ptr</span><span style="font-family:宋体">）中就使用了这种技术。在有这种需要的时候，我们就希望我们的资源封装类只能在栈中创建，也就是要限制在堆中创建该资源封装类的实例。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:16pt"><strong><span style="font-family:Verdana">3.1.4?</span><span style="font-family:宋体">禁止产生堆对象</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　上面已经提到，你决定禁止产生某种类型的堆对象，这时你可以自己创建一个资源封装类，该类对象只能在栈中产生，这样就能在异常的情况下自动释放封装的资源。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　那么怎样禁止产生堆对象了？我们已经知道，产生堆对象的唯一方法是使用</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">操作，如果我们禁止使用</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">不就行了么。再进一步，</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">操作执行时会调用</span><span style="font-family:Verdana">operator new</span><span style="font-family:宋体">，而</span><span style="font-family:Verdana">operator new</span><span style="font-family:宋体">是可以重载的。方法有了，就是使</span><span style="font-family:Verdana">new operator?</span><span style="font-family:宋体">为</span><span style="font-family:Verdana">private</span><span style="font-family:宋体">，为了对称，最好将</span><span style="font-family:Verdana">operator delete</span><span style="font-family:宋体">也重载为</span><span style="font-family:Verdana">private</span><span style="font-family:宋体">。现在，你也许又有疑问了</span><span style="font-family:Verdana">,</span><span style="font-family:宋体">难道创建栈对象不需要调用</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">吗？是的，不需要，因为创建栈对象不需要搜索内存，而是直接调整堆栈指针，将对象压栈，而</span><span style="font-family:Verdana">operator new</span><span style="font-family:宋体">的主要任务是搜索合适的堆内存，为堆对象分配空间，这在上面已经提到过了。好，让我们看看下面的示例代码：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-size:8pt"><span style="font-family:Verdana">#include &lt;stdlib.h&gt; //</span><span style="font-family:宋体">需要用到</span><span style="font-family:Verdana">C</span><span style="font-family:宋体">式内存分配函数</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">class Resource ; //</span><span style="font-family:宋体">代表需要被封装的资源类</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">class NoHashObject
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">private:
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">Resource* ptr ;//</span><span style="font-family:宋体">指向被封装的资源</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">... ... //</span><span style="font-family:宋体">其它数据成员</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">void* operator new(size_t size) //</span><span style="font-family:宋体">非严格实现，仅作示意之用</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">{
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　</span><span style="font-family:Verdana">return malloc(size) ;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">}
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">void operator delete(void* pp) //</span><span style="font-family:宋体">非严格实现，仅作示意之用</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">{
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　</span><span style="font-family:Verdana">free(pp) ;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">}
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">public:
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">NoHashObject()
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">{
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　</span><span style="font-family:Verdana">//</span><span style="font-family:宋体">此处可以获得需要封装的资源，并让</span><span style="font-family:Verdana">ptr</span><span style="font-family:宋体">指针指向该资源</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　</span><span style="font-family:Verdana">ptr = new Resource() ;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">}
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">~NoHashObject()
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">{
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　</span><span style="font-family:Verdana">delete ptr ; //</span><span style="font-family:宋体">释放封装的资源</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">}
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">};?
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">NoHashObject</span><span style="font-family:宋体">现在就是一个禁止堆对象的类了，如果你写下如下代码：</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">NoHashObject* fp = new NoHashObject() ; //</span><span style="font-family:宋体">编译期错误！</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">delete fp ;?</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">上面代码会产生编译期错误。好了，现在你已经知道了如何设计一个禁止堆对象的类了，你也许和我一样有这样的疑问，难道在类</span><span style="font-family:Verdana">NoHashObject</span><span style="font-family:宋体">的定义不能改变的情况下，就一定不能产生该类型的堆对象了吗？不，还是有办法的，我称之为"暴力破解法"。</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">是如此地强大，强大到你可以用它做你想做的任何事情。这里主要用到的是技巧是指针类型的强制转换。</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">void main(void)
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">char* temp = new char[sizeof(NoHashObject)] ;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">//</span><span style="font-family:宋体">强制类型转换，现在</span><span style="font-family:Verdana">ptr</span><span style="font-family:宋体">是一个指向</span><span style="font-family:Verdana">NoHashObject</span><span style="font-family:宋体">对象的指针</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">NoHashObject* obj_ptr = (NoHashObject*)temp ;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">temp = NULL ; //</span><span style="font-family:宋体">防止通过</span><span style="font-family:Verdana">temp</span><span style="font-family:宋体">指针修改</span><span style="font-family:Verdana">NoHashObject</span><span style="font-family:宋体">对象</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">//</span><span style="font-family:宋体">再一次强制类型转换，让</span><span style="font-family:Verdana">rp</span><span style="font-family:宋体">指针指向堆中</span><span style="font-family:Verdana">NoHashObject</span><span style="font-family:宋体">对象的</span><span style="font-family:Verdana">ptr</span><span style="font-family:宋体">成员</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">Resource* rp = (Resource*)obj_ptr ;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">//</span><span style="font-family:宋体">初始化</span><span style="font-family:Verdana">obj_ptr</span><span style="font-family:宋体">指向的</span><span style="font-family:Verdana">NoHashObject</span><span style="font-family:宋体">对象的</span><span style="font-family:Verdana">ptr</span><span style="font-family:宋体">成员</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">rp = new Resource() ;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">//</span><span style="font-family:宋体">现在可以通过使用</span><span style="font-family:Verdana">obj_ptr</span><span style="font-family:宋体">指针使用堆中的</span><span style="font-family:Verdana">NoHashObject</span><span style="font-family:宋体">对象成员了</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">... ...
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">delete rp ;//</span><span style="font-family:宋体">释放资源</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">temp = (char*)obj_ptr ;
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">obj_ptr = NULL ;//</span><span style="font-family:宋体">防止悬挂指针产生</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">delete [] temp ;//</span><span style="font-family:宋体">释放</span><span style="font-family:Verdana">NoHashObject</span><span style="font-family:宋体">对象所占的堆空间。</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">}?</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　上面的实现是麻烦的，而且这种实现方式几乎不会在实践中使用，但是我还是写出来路，因为理解它，对于我们理解</span><span style="font-family:Verdana">C++</span><span style="font-family:宋体">内存对象是有好处的。对于上面的这么多强制类型转换，其最根本的是什么了？我们可以这样理解：</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　某块内存中的数据是不变的，而类型就是我们戴上的眼镜，当我们戴上一种眼镜后，我们就会用对应的类型来解释内存中的数据，这样不同的解释就得到了不同的信息。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　所谓强制类型转换实际上就是换上另一副眼镜后再来看同样的那块内存数据。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　另外要提醒的是，不同的编译器对对象的成员数据的布局安排可能是不一样的，比如，大多数编译器将</span><span style="font-family:Verdana">NoHashObject</span><span style="font-family:宋体">的</span><span style="font-family:Verdana">ptr</span><span style="font-family:宋体">指针成员安排在对象空间的头</span><span style="font-family:Verdana">4</span><span style="font-family:宋体">个字节，这样才会保证下面这条语句的转换动作像我们预期的那样执行：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">Resource* rp = (Resource*)obj_ptr ;?</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　但是，并不一定所有的编译器都是如此。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　既然我们可以禁止产生某种类型的堆对象，那么可以设计一个类，使之不能产生栈对象吗？当然可以。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><strong><span style="font-family:Verdana">3.1.5?</span><span style="font-family:宋体">禁止产生栈对象</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　前面已经提到了，创建栈对象时会移动栈顶指针以"挪出"适当大小的空间，然后在这个空间上直接调用对应的构造函数以形成一个栈对象，而当函数返回时，会调用其析构函数释放这个对象，然后再调整栈顶指针收回那块栈内存。在这个过程中是不需要</span><span style="font-family:Verdana">operator new/delete</span><span style="font-family:宋体">操作的，所以将</span><span style="font-family:Verdana">operator new/delete</span><span style="font-family:宋体">设置为</span><span style="font-family:Verdana">private</span><span style="font-family:宋体">不能达到目的。当然从上面的叙述中，你也许已经想到了：将构造函数或析构函数设为私有的，这样系统就不能调用构造</span><span style="font-family:Verdana">/</span><span style="font-family:宋体">析构函数了，当然就不能在栈中生成对象了。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　这样的确可以，而且我也打算采用这种方案。但是在此之前，有一点需要考虑清楚</span><span style="font-family:Verdana">,</span><span style="font-family:宋体">那就是，如果我们将构造函数设置为私有，那么我们也就不能用</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">来直接产生堆对象了，因为</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">在为对象分配空间后也会调用它的构造函数啊。所以，我打算只将析构函数设置为</span><span style="font-family:Verdana">private</span><span style="font-family:宋体">。再进一步，将析构函数设为</span><span style="font-family:Verdana">private</span><span style="font-family:宋体">除了会限制栈对象生成外，还有其它影响吗？是的，这还会限制继承。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　如果一个类不打算作为基类，通常采用的方案就是将其析构函数声明为</span><span style="font-family:Verdana">private</span><span style="font-family:宋体">。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　为了限制栈对象，却不限制继承，我们可以将析构函数声明为</span><span style="font-family:Verdana">protected</span><span style="font-family:宋体">，这样就两全其美了。如下代码所示：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">class NoStackObject
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">protected:
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">~NoStackObject() { }
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">public:
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">void destroy()
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">{
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　</span><span style="font-family:Verdana">delete this ;//</span><span style="font-family:宋体">调用保护析构函数</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">}
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">};?</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　接着，可以像这样使用</span><span style="font-family:Verdana">NoStackObject</span><span style="font-family:宋体">类：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">NoStackObject* hash_ptr = new NoStackObject() ;
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">... ... //</span><span style="font-family:宋体">对</span><span style="font-family:Verdana">hash_ptr</span><span style="font-family:宋体">指向的对象进行操作</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">hash_ptr-&gt;destroy() ;?</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　呵呵，是不是觉得有点怪怪的，我们用</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">创建一个对象，却不是用</span><span style="font-family:Verdana">delete</span><span style="font-family:宋体">去删除它，而是要用</span><span style="font-family:Verdana">destroy</span><span style="font-family:宋体">方法。很显然，用户是不习惯这种怪异的使用方式的。所以，我决定将构造函数也设为</span><span style="font-family:Verdana">private</span><span style="font-family:宋体">或</span><span style="font-family:Verdana">protected</span><span style="font-family:宋体">。这又回到了上面曾试图避免的问题，即不用</span><span style="font-family:Verdana">new</span><span style="font-family:宋体">，那么该用什么方式来生成一个对象了？我们可以用间接的办法完成，即让这个类提供一个</span><span style="font-family:Verdana">static</span><span style="font-family:宋体">成员函数专门用于产生该类型的堆对象。（设计模式中的</span><span style="font-family:Verdana">singleton</span><span style="font-family:宋体">模式就可以用这种方式实现。）让我们来看看：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">class NoStackObject
</span></p><p><span style="font-family:Verdana; font-size:8pt">{
</span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">protected:
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">NoStackObject() { }
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">~NoStackObject() { }
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　</span><span style="font-family:Verdana">public:
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">static NoStackObject* creatInstance()
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">{
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　</span><span style="font-family:Verdana">return new NoStackObject() ;//</span><span style="font-family:宋体">调用保护的构造函数</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">}
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">void destroy()
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">{
</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　　</span><span style="font-family:Verdana">delete this ;//</span><span style="font-family:宋体">调用保护的析构函数</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-size:8pt"><span style="font-family:宋体">　　</span><span style="font-family:Verdana">}
</span></span></p><p><span style="font-family:Verdana; font-size:8pt">};</span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　现在可以这样使用</span><span style="font-family:Verdana">NoStackObject</span><span style="font-family:宋体">类了：</span><span style="font-family:Verdana">
			</span></span></p><div><table style="border-collapse:collapse; background: #e0e0e0" border="0"><colgroup><col style="width:710px"/></colgroup><tbody valign="top"><tr><td style="padding-left: 9px; padding-right: 9px; border-top:  solid 1.0pt; border-left:  solid 1.0pt; border-bottom:  solid 1.0pt; border-right:  solid 1.0pt"><p><span style="font-family:Verdana; font-size:8pt">NoStackObject* hash_ptr = NoStackObject::creatInstance() ;
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">... ... //</span><span style="font-family:宋体">对</span><span style="font-family:Verdana">hash_ptr</span><span style="font-family:宋体">指向的对象进行操作</span><span style="font-family:Verdana">
								</span></span></p><p><span style="font-family:Verdana; font-size:8pt">hash_ptr-&gt;destroy() ;
</span></p><p><span style="font-size:8pt"><span style="font-family:Verdana">hash_ptr = NULL ; //</span><span style="font-family:宋体">防止使用悬挂指针</span><span style="font-family:Verdana">?</span></span></p></td></tr></tbody></table></div><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">现在感觉是不是好多了，生成对象和释放对象的操作一致了。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:18pt"><strong><span style="font-family:Verdana">3.2?</span><span style="font-family:黑体">浅议</span><span style="font-family:Verdana">C++?</span><span style="font-family:黑体">中的垃圾回收方法</span><span style="font-family:Verdana">
				</span></strong></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　许多</span><span style="font-family:Verdana">?C?</span><span style="font-family:宋体">或者</span><span style="font-family:Verdana">?C++?</span><span style="font-family:宋体">程序员对垃圾回收嗤之以鼻，认为垃圾回收肯定比自己来管理动态内存要低效，而且在回收的时候一定会让程序停顿在那里，而如果自己控制内存管理的话，分配和释放时间都是稳定的，不会导致程序停顿。最后，很多</span><span style="font-family:Verdana">?C/C++?</span><span style="font-family:宋体">程序员坚信在</span><span style="font-family:Verdana">C/C++?</span><span style="font-family:宋体">中无法实现垃圾回收机制。这些错误的观点都是由于不了解垃圾回收的算法而臆想出来的。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　其实垃圾回收机制并不慢，甚至比动态内存分配更高效。因为我们可以只分配不释放，那么分配内存的时候只需要从堆上一直的获得新的内存，移动堆顶的指针就够了；而释放的过程被省略了，自然也加快了速度。现代的垃圾回收算法已经发展了很多，增量收集算法已经可以让垃圾回收过程分段进行，避免打断程序的运行了。而传统的动态内存管理的算法同样有在适当的时间收集内存碎片的工作要做，并不比垃圾回收更有优势。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　而垃圾回收的算法的基础通常基于扫描并标记当前可能被使用的所有内存块，从已经被分配的所有内存中把未标记的内存回收来做的。</span><span style="font-family:Verdana">C/C++?</span><span style="font-family:宋体">中无法实现垃圾回收的观点通常基于无法正确扫描出所有可能还会被使用的内存块，但是，看似不可能的事情实际上实现起来却并不复杂。首先，通过扫描内存的数据，指向堆上动态分配出来内存的指针是很容易被识别出来的，如果有识别错误，也只能是把一些不是指针的数据当成指针，而不会把指针当成非指针数据。这样，回收垃圾的过程只会漏回收掉而不会错误的把不应该回收的内存清理。其次，如果回溯所有内存块被引用的根，只可能存在于全局变量和当前的栈内，而全局变量</span><span style="font-family:Verdana">(</span><span style="font-family:宋体">包括函数内的静态变量</span><span style="font-family:Verdana">)</span><span style="font-family:宋体">都是集中存在于</span><span style="font-family:Verdana">?bss?</span><span style="font-family:宋体">段或</span><span style="font-family:Verdana">?data</span><span style="font-family:宋体">段中。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　垃圾回收的时候，只需要扫描</span><span style="font-family:Verdana">?bss?</span><span style="font-family:宋体">段</span><span style="font-family:Verdana">, data?</span><span style="font-family:宋体">段以及当前被使用着的栈空间，找到可能是动态内存指针的量，把引用到的内存递归扫描就可以得到当前正在使用的所有动态内存了。</span><span style="font-family:Verdana">
			</span></span></p><p><span style="color:#4b4b4b; font-size:8pt"><span style="font-family:宋体">　　如果肯为你的工程实现一个不错的垃圾回收器，提高内存管理的速度，甚至减少总的内存消耗都是可能的。如果有</span><span style="font-family:Verdana">
			</span></span></p>
